'use strict';

var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var reactTable = require('@tanstack/react-table');
var matchSorterUtils = require('@tanstack/match-sorter-utils');
var iconsReact = require('@tabler/icons-react');
var reactVirtual = require('@tanstack/react-virtual');
var core = require('@mantine/core');
var hooks = require('@mantine/hooks');
var dates = require('@mantine/dates');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const MRT_AggregationFns = Object.assign({}, reactTable.aggregationFns);

const fuzzy$1 = (row, columnId, filterValue, addMeta) => {
    const itemRank = matchSorterUtils.rankItem(row.getValue(columnId), filterValue, {
        threshold: matchSorterUtils.rankings.MATCHES,
    });
    addMeta(itemRank);
    return itemRank.passed;
};
fuzzy$1.autoRemove = (val) => !val;
const contains = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
const startsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
const endsWith = (row, id, filterValue) => row
    .getValue(id)
    .toString()
    .toLowerCase()
    .trim()
    .endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
const equals = (row, id, filterValue) => filterValue === null
    ? true
    : row.getValue(id).toString().toLowerCase().trim() ===
        filterValue.toString().toLowerCase().trim();
equals.autoRemove = (val) => !val;
const notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !==
    filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
const greaterThan = (row, id, filterValue) => filterValue === null
    ? true
    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))
        ? +row.getValue(id) > +filterValue
        : row.getValue(id).toString().toLowerCase().trim() >
            filterValue.toString().toLowerCase().trim();
greaterThan.autoRemove = (val) => !val;
const greaterThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
const lessThan = (row, id, filterValue) => filterValue === null
    ? true
    : !isNaN(+filterValue) && !isNaN(+row.getValue(id))
        ? +row.getValue(id) < +filterValue
        : row.getValue(id).toString().toLowerCase().trim() <
            filterValue.toString().toLowerCase().trim();
lessThan.autoRemove = (val) => !val;
const lessThanOrEqualTo = (row, id, filterValue) => equals(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
const between = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThan(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
const betweenInclusive = (row, id, filterValues) => (['', undefined].includes(filterValues[0]) ||
    greaterThanOrEqualTo(row, id, filterValues[0])) &&
    ((!isNaN(+filterValues[0]) &&
        !isNaN(+filterValues[1]) &&
        +filterValues[0] > +filterValues[1]) ||
        ['', undefined].includes(filterValues[1]) ||
        lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
const empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
const notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
const MRT_FilterFns = Object.assign(Object.assign({}, reactTable.filterFns), { between,
    betweenInclusive,
    contains,
    empty,
    endsWith,
    equals,
    fuzzy: fuzzy$1,
    greaterThan,
    greaterThanOrEqualTo,
    lessThan,
    lessThanOrEqualTo,
    notEmpty,
    notEquals,
    startsWith });

const fuzzy = (rowA, rowB, columnId) => {
    let dir = 0;
    if (rowA.columnFiltersMeta[columnId]) {
        dir = matchSorterUtils.compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
    }
    // Provide a fallback for when the item ranks are equal
    return dir === 0
        ? reactTable.sortingFns.alphanumeric(rowA, rowB, columnId)
        : dir;
};
const MRT_SortingFns = Object.assign(Object.assign({}, reactTable.sortingFns), { fuzzy });
const rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) -
    Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));

const getColumnId = (columnDef) => { var _a, _b, _c, _d; return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header; };
const getAllLeafColumnDefs = (columns) => {
    const allLeafColumnDefs = [];
    const getLeafColumns = (cols) => {
        cols.forEach((col) => {
            if (col.columns) {
                getLeafColumns(col.columns);
            }
            else {
                allLeafColumnDefs.push(col);
            }
        });
    };
    getLeafColumns(columns);
    return allLeafColumnDefs;
};
const prepareColumns = ({ aggregationFns, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns, sortingFns, }) => columnDefs.map((columnDef) => {
    var _a, _b;
    //assign columnId
    if (!columnDef.id)
        columnDef.id = getColumnId(columnDef);
    if (process.env.NODE_ENV !== 'production' && !columnDef.id) {
        console.error('Column definitions must have a valid `accessorKey` or `id` property');
    }
    //assign columnDefType
    if (!columnDef.columnDefType)
        columnDef.columnDefType = 'data';
    if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
        columnDef.columnDefType = 'group';
        //recursively prepare columns if this is a group column
        columnDef.columns = prepareColumns({
            aggregationFns,
            columnDefs: columnDef.columns,
            columnFilterFns,
            defaultDisplayColumn,
            filterFns,
            sortingFns,
        });
    }
    else if (columnDef.columnDefType === 'data') {
        //assign aggregationFns if multiple aggregationFns are provided
        if (Array.isArray(columnDef.aggregationFn)) {
            const aggFns = columnDef.aggregationFn;
            columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => { var _a; return (_a = aggregationFns[fn]) === null || _a === void 0 ? void 0 : _a.call(aggregationFns, columnId, leafRows, childRows); });
        }
        //assign filterFns
        if (Object.keys(filterFns).includes(columnFilterFns[columnDef.id])) {
            columnDef.filterFn =
                (_b = filterFns[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns.fuzzy;
            columnDef._filterFn =
                columnFilterFns[columnDef.id];
        }
        //assign sortingFns
        if (Object.keys(sortingFns).includes(columnDef.sortingFn)) {
            // @ts-ignore
            columnDef.sortingFn = sortingFns[columnDef.sortingFn];
        }
    }
    else if (columnDef.columnDefType === 'display') {
        columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
    }
    return columnDef;
});
const reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
    if (draggedColumn.getCanPin()) {
        draggedColumn.pin(targetColumn.getIsPinned());
    }
    columnOrder.splice(columnOrder.indexOf(targetColumn.id), 0, columnOrder.splice(columnOrder.indexOf(draggedColumn.id), 1)[0]);
    return [...columnOrder];
};
const showExpandColumn = (props, grouping) => !!(props.enableExpanding ||
    (props.enableGrouping && (grouping === undefined || (grouping === null || grouping === void 0 ? void 0 : grouping.length))) ||
    props.renderDetailPanel);
const getLeadingDisplayColumnIds = (props) => {
    var _a;
    return [
        (props.enableRowDragging || props.enableRowOrdering) && 'mrt-row-drag',
        props.positionActionsColumn === 'first' &&
            (props.enableRowActions ||
                (props.enableEditing &&
                    ['row', 'modal', 'custom'].includes((_a = props.editDisplayMode) !== null && _a !== void 0 ? _a : ''))) &&
            'mrt-row-actions',
        props.positionExpandColumn === 'first' &&
            showExpandColumn(props) &&
            'mrt-row-expand',
        props.enableRowSelection && 'mrt-row-select',
        props.enableRowNumbers && 'mrt-row-numbers',
    ].filter(Boolean);
};
const getTrailingDisplayColumnIds = (props) => {
    var _a;
    return [
        props.positionActionsColumn === 'last' &&
            (props.enableRowActions ||
                (props.enableEditing &&
                    ['row', 'modal'].includes((_a = props.editDisplayMode) !== null && _a !== void 0 ? _a : ''))) &&
            'mrt-row-actions',
        props.positionExpandColumn === 'last' &&
            showExpandColumn(props) &&
            'mrt-row-expand',
    ].filter(Boolean);
};
const getDefaultColumnOrderIds = (props) => {
    const leadingDisplayCols = getLeadingDisplayColumnIds(props);
    const trailingDisplayCols = getTrailingDisplayColumnIds(props);
    const allLeafColumnDefs = getAllLeafColumnDefs(props.columns)
        .map((columnDef) => getColumnId(columnDef))
        .filter((columnId) => !leadingDisplayCols.includes(columnId) &&
        !trailingDisplayCols.includes(columnId));
    return [...leadingDisplayCols, ...allLeafColumnDefs, ...trailingDisplayCols];
};
const getDefaultColumnFilterFn = (columnDef) => {
    const { filterVariant } = columnDef;
    if (filterVariant === 'multi-select')
        return 'arrIncludesSome';
    if (['range', 'date-range', 'range-slider'].includes(filterVariant || ''))
        return 'betweenInclusive';
    if (['select', 'checkbox', 'date'].includes(filterVariant || ''))
        return 'equals';
    return 'fuzzy';
};
const getIsFirstColumn = (column, table) => {
    return table.getVisibleLeafColumns()[0].id === column.id;
};
const getIsLastColumn = (column, table) => {
    const columns = table.getVisibleLeafColumns();
    return columns[columns.length - 1].id === column.id;
};
const getIsLastLeftPinnedColumn = (table, column) => {
    return (column.getIsPinned() === 'left' &&
        table.getLeftLeafHeaders().length - 1 === column.getPinnedIndex());
};
const getIsFirstRightPinnedColumn = (column) => {
    return column.getIsPinned() === 'right' && column.getPinnedIndex() === 0;
};
const getTotalRight = (table, column) => {
    return table
        .getRightLeafHeaders()
        .slice(column.getPinnedIndex() + 1)
        .reduce((acc, col) => acc + col.getSize(), 0);
};
const getCanRankRows = (table) => {
    const { options, getState } = table;
    const { manualExpanding, manualFiltering, manualGrouping, manualSorting, enableGlobalFilterRankedResults, } = options;
    const { globalFilterFn, expanded } = getState();
    return (!manualExpanding &&
        !manualFiltering &&
        !manualGrouping &&
        !manualSorting &&
        enableGlobalFilterRankedResults &&
        globalFilterFn === 'fuzzy' &&
        expanded !== true &&
        !Object.values(expanded).some(Boolean));
};
const getCommonCellStyles = ({ column, header, isStriped, row, table, tableCellProps, theme, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const widthStyles = {
        minWidth: `max(calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = column.columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
        width: `calc(var(--${header ? 'header' : 'col'}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`,
    };
    return Object.assign(Object.assign(Object.assign({ backgroundColor: row
            ? (row === null || row === void 0 ? void 0 : row.getIsSelected())
                ? theme.fn.rgba(getPrimaryColor(theme), 0.1)
                : column.getIsPinned() && column.columnDef.columnDefType !== 'group'
                    ? theme.fn.rgba(theme.colorScheme === 'dark'
                        ? theme.fn.darken(theme.colors.dark[7], 0.02)
                        : theme.white, 0.97)
                    : isStriped
                        ? 'inherit'
                        : theme.colorScheme === 'dark'
                            ? theme.fn.lighten(theme.colors.dark[7], 0.02)
                            : theme.white
            : 'inherit', backgroundClip: 'padding-box', boxShadow: getIsLastLeftPinnedColumn(table, column)
            ? `-4px 0 8px -6px ${theme.fn.rgba(theme.black, 0.2)} inset`
            : getIsFirstRightPinnedColumn(column)
                ? `4px 0 8px -6px ${theme.fn.rgba(theme.black, 0.2)} inset`
                : undefined, display: table.options.layoutMode === 'grid' ? 'flex' : 'table-cell', flex: table.options.layoutMode === 'grid'
            ? `var(--${header ? 'header' : 'col'}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size) 0 auto`
            : undefined, left: column.getIsPinned() === 'left'
            ? `${column.getStart('left')}px`
            : undefined, ml: table.options.enableColumnVirtualization &&
            column.getIsPinned() === 'left' &&
            column.getPinnedIndex() === 0
            ? `-${column.getSize() *
                ((_f = (_e = table.getState().columnPinning.left) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 1)}px`
            : undefined, mr: table.options.enableColumnVirtualization &&
            column.getIsPinned() === 'right' &&
            column.getPinnedIndex() === table.getVisibleLeafColumns().length - 1
            ? `-${column.getSize() *
                ((_h = (_g = table.getState().columnPinning.right) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 1) *
                1.2}px`
            : undefined, opacity: ((_j = table.getState().draggingColumn) === null || _j === void 0 ? void 0 : _j.id) === column.id ||
            ((_k = table.getState().hoveredColumn) === null || _k === void 0 ? void 0 : _k.id) === column.id
            ? 0.5
            : 1, position: column.getIsPinned() && column.columnDef.columnDefType !== 'group'
            ? 'sticky'
            : undefined, right: column.getIsPinned() === 'right'
            ? `${getTotalRight(table, column)}px`
            : undefined, transition: table.options.enableColumnVirtualization
            ? 'none'
            : `padding 100ms ease-in-out` }, (!table.options.enableColumnResizing && widthStyles)), ((tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function
        ? tableCellProps.sx(theme)
        : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx)), (table.options.enableColumnResizing && widthStyles));
};
const MRT_DefaultColumn = {
    filterVariant: 'text',
    minSize: 40,
    maxSize: 1000,
    size: 180,
};
const MRT_DefaultDisplayColumn = {
    columnDefType: 'display',
    enableClickToCopy: false,
    enableColumnActions: false,
    enableColumnDragging: false,
    enableColumnFilter: false,
    enableColumnOrdering: false,
    enableEditing: false,
    enableGlobalFilter: false,
    enableGrouping: false,
    enableHiding: false,
    enableResizing: false,
    enableSorting: false,
};
const getPrimaryShade = (theme) => {
    var _a, _b, _c, _d, _e;
    return (_e = (theme.colorScheme === 'dark'
        ? // @ts-ignore
            (_b = (_a = theme.primaryShade) === null || _a === void 0 ? void 0 : _a.dark) !== null && _b !== void 0 ? _b : theme.primaryShade
        : // @ts-ignore
            (_d = (_c = theme.primaryShade) === null || _c === void 0 ? void 0 : _c.light) !== null && _d !== void 0 ? _d : theme.primaryShade)) !== null && _e !== void 0 ? _e : 7;
};
const getPrimaryColor = (theme, shade) => theme.colors[theme.primaryColor][shade !== null && shade !== void 0 ? shade : getPrimaryShade(theme)];
const parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, '_');
const flexRender = reactTable.flexRender;
const createRow = (table, originalRow) => reactTable.createRow(table, 'mrt-row-create', originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns)
    .filter((c) => c.columnDefType === 'data')
    .map((col) => ({
    [getColumnId(col)]: '',
}))), -1, 0);

const MRT_Localization_EN = {
    actions: 'Actions',
    and: 'and',
    cancel: 'Cancel',
    changeFilterMode: 'Change filter mode',
    changeSearchMode: 'Change search mode',
    clearFilter: 'Clear filter',
    clearSearch: 'Clear search',
    clearSort: 'Clear sort',
    clickToCopy: 'Click to copy',
    collapse: 'Collapse',
    collapseAll: 'Collapse all',
    columnActions: 'Column Actions',
    copiedToClipboard: 'Copied to clipboard',
    dropToGroupBy: 'Drop to group by {column}',
    edit: 'Edit',
    expand: 'Expand',
    expandAll: 'Expand all',
    filterArrIncludes: 'Includes',
    filterArrIncludesAll: 'Includes all',
    filterArrIncludesSome: 'Includes',
    filterBetween: 'Between',
    filterBetweenInclusive: 'Between Inclusive',
    filterByColumn: 'Filter by {column}',
    filterContains: 'Contains',
    filterEmpty: 'Empty',
    filterEndsWith: 'Ends With',
    filterEquals: 'Equals',
    filterEqualsString: 'Equals',
    filterFuzzy: 'Fuzzy',
    filterGreaterThan: 'Greater Than',
    filterGreaterThanOrEqualTo: 'Greater Than Or Equal To',
    filterInNumberRange: 'Between',
    filterIncludesString: 'Contains',
    filterIncludesStringSensitive: 'Contains',
    filterLessThan: 'Less Than',
    filterLessThanOrEqualTo: 'Less Than Or Equal To',
    filterMode: 'Filter Mode: {filterType}',
    filterNotEmpty: 'Not Empty',
    filterNotEquals: 'Not Equals',
    filterStartsWith: 'Starts With',
    filterWeakEquals: 'Equals',
    filteringByColumn: 'Filtering by {column} - {filterType} {filterValue}',
    goToFirstPage: 'Go to first page',
    goToLastPage: 'Go to last page',
    goToNextPage: 'Go to next page',
    goToPreviousPage: 'Go to previous page',
    grab: 'Grab',
    groupByColumn: 'Group by {column}',
    groupedBy: 'Grouped by ',
    hideAll: 'Hide all',
    hideColumn: 'Hide {column} column',
    max: 'Max',
    min: 'Min',
    move: 'Move',
    noRecordsToDisplay: 'No records to display',
    noResultsFound: 'No results found',
    of: 'of',
    or: 'or',
    pinToLeft: 'Pin to left',
    pinToRight: 'Pin to right',
    resetColumnSize: 'Reset column size',
    resetOrder: 'Reset order',
    rowActions: 'Row Actions',
    rowNumber: '#',
    rowNumbers: 'Row Numbers',
    rowsPerPage: 'Rows per page',
    save: 'Save',
    search: 'Search',
    selectedCountOfRowCountRowsSelected: '{selectedCount} of {rowCount} row(s) selected',
    select: 'Select',
    showAll: 'Show all',
    showAllColumns: 'Show all columns',
    showHideColumns: 'Show/Hide columns',
    showHideFilters: 'Show/Hide filters',
    showHideSearch: 'Show/Hide search',
    sortByColumnAsc: 'Sort by {column} ascending',
    sortByColumnDesc: 'Sort by {column} descending',
    sortedByColumnAsc: 'Sorted by {column} ascending',
    sortedByColumnDesc: 'Sorted by {column} descending',
    thenBy: ', then by ',
    toggleDensity: 'Toggle density',
    toggleFullScreen: 'Toggle full screen',
    toggleSelectAll: 'Toggle select all',
    toggleSelectRow: 'Toggle select row',
    toggleVisibility: 'Toggle visibility',
    ungroupByColumn: 'Ungroup by {column}',
    unpin: 'Unpin',
    unpinAll: 'Unpin all',
};

const MRT_Default_Icons = {
    IconArrowAutofitContent: iconsReact.IconArrowAutofitContent,
    IconArrowsSort: iconsReact.IconArrowsSort,
    IconBaselineDensityLarge: iconsReact.IconBaselineDensityLarge,
    IconBaselineDensityMedium: iconsReact.IconBaselineDensityMedium,
    IconBaselineDensitySmall: iconsReact.IconBaselineDensitySmall,
    IconBoxMultiple: iconsReact.IconBoxMultiple,
    IconChevronDown: iconsReact.IconChevronDown,
    IconChevronLeft: iconsReact.IconChevronLeft,
    IconChevronLeftPipe: iconsReact.IconChevronLeftPipe,
    IconChevronRight: iconsReact.IconChevronRight,
    IconChevronRightPipe: iconsReact.IconChevronRightPipe,
    IconChevronsDown: iconsReact.IconChevronsDown,
    IconCircleX: iconsReact.IconCircleX,
    IconClearAll: iconsReact.IconClearAll,
    IconColumns: iconsReact.IconColumns,
    IconDeviceFloppy: iconsReact.IconDeviceFloppy,
    IconDots: iconsReact.IconDots,
    IconDotsVertical: iconsReact.IconDotsVertical,
    IconEdit: iconsReact.IconEdit,
    IconEyeOff: iconsReact.IconEyeOff,
    IconFilter: iconsReact.IconFilter,
    IconFilterCog: iconsReact.IconFilterCog,
    IconFilterOff: iconsReact.IconFilterOff,
    IconGripHorizontal: iconsReact.IconGripHorizontal,
    IconMaximize: iconsReact.IconMaximize,
    IconMinimize: iconsReact.IconMinimize,
    IconPinned: iconsReact.IconPinned,
    IconPinnedOff: iconsReact.IconPinnedOff,
    IconSearch: iconsReact.IconSearch,
    IconSearchOff: iconsReact.IconSearchOff,
    IconSortAscending: iconsReact.IconSortAscending,
    IconSortDescending: iconsReact.IconSortDescending,
    IconX: iconsReact.IconX,
};

const useMRT_TableOptions = (_a) => {
    var _b;
    var { aggregationFns, autoResetExpanded = false, columnFilterDisplayMode = 'subheader', columnResizeMode = 'onChange', createDisplayMode = 'modal', defaultColumn, defaultDisplayColumn, editDisplayMode = 'modal', enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnResizing = false, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enablePinning = false, enableRowSelection = false, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns, icons, layoutMode = 'semantic', localization, manualFiltering, manualGrouping, manualPagination, manualSorting, paginationDisplayMode = 'default', positionActionsColumn = 'first', positionExpandColumn = 'first', positionGlobalFilter = 'right', positionPagination = 'bottom', positionToolbarAlertBanner = 'top', positionToolbarDropZone = 'top', rowNumberMode = 'static', selectAllMode = 'page', sortingFns } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnFilterDisplayMode", "columnResizeMode", "createDisplayMode", "defaultColumn", "defaultDisplayColumn", "editDisplayMode", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnResizing", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enablePinning", "enableRowSelection", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "paginationDisplayMode", "positionActionsColumn", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberMode", "selectAllMode", "sortingFns"]);
    const _icons = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Default_Icons), icons)), [icons]);
    const _localization = react.useMemo(() => (Object.assign(Object.assign({}, MRT_Localization_EN), localization)), [localization]);
    const _aggregationFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns)), []);
    const _filterFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_FilterFns), filterFns)), []);
    const _sortingFns = react.useMemo(() => (Object.assign(Object.assign({}, MRT_SortingFns), sortingFns)), []);
    const _defaultColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn)), [defaultColumn]);
    const _defaultDisplayColumn = react.useMemo(() => (Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn)), [defaultDisplayColumn]);
    if (rest.enableRowVirtualization || rest.enableColumnVirtualization) {
        layoutMode = 'grid';
    }
    if (rest.enableRowVirtualization) {
        enableStickyHeader = true;
    }
    if (enablePagination === false && manualPagination === undefined) {
        manualPagination = true;
    }
    if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {
        manualFiltering = true;
        manualGrouping = true;
        manualPagination = true;
        manualSorting = true;
    }
    return Object.assign({ aggregationFns: _aggregationFns, autoResetExpanded,
        columnFilterDisplayMode,
        columnResizeMode,
        createDisplayMode, defaultColumn: _defaultColumn, defaultDisplayColumn: _defaultDisplayColumn, editDisplayMode,
        enableBottomToolbar,
        enableColumnActions,
        enableColumnFilters,
        enableColumnOrdering,
        enableColumnResizing,
        enableDensityToggle,
        enableExpandAll,
        enableExpanding,
        enableFilterMatchHighlighting,
        enableFilters,
        enableFullScreenToggle,
        enableGlobalFilter,
        enableGlobalFilterRankedResults,
        enableGrouping,
        enableHiding,
        enableMultiRowSelection,
        enableMultiSort,
        enablePagination,
        enablePinning,
        enableRowSelection,
        enableSelectAll,
        enableSorting,
        enableStickyHeader,
        enableTableFooter,
        enableTableHead,
        enableToolbarInternalActions,
        enableTopToolbar, filterFns: _filterFns, icons: _icons, layoutMode, localization: _localization, manualFiltering,
        manualGrouping,
        manualPagination,
        manualSorting,
        paginationDisplayMode,
        positionActionsColumn,
        positionExpandColumn,
        positionGlobalFilter,
        positionPagination,
        positionToolbarAlertBanner,
        positionToolbarDropZone,
        rowNumberMode,
        selectAllMode, sortingFns: _sortingFns }, rest);
};

const MRT_EditCellTextInput = ({ cell, table, }) => {
    var _a;
    const { getState, options: { createDisplayMode, editDisplayMode, mantineEditTextInputProps, mantineEditSelectProps, }, refs: { editInputRefs }, setEditingCell, setEditingRow, setCreatingRow, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const isSelectEdit = columnDef.editVariant === 'select';
    const [value, setValue] = react.useState(() => cell.getValue());
    const mTableBodyCellEditTextInputProps = mantineEditTextInputProps instanceof Function
        ? mantineEditTextInputProps({ cell, column, row, table })
        : mantineEditTextInputProps;
    const mcTableBodyCellEditTextInputProps = columnDef.mantineEditTextInputProps instanceof Function
        ? columnDef.mantineEditTextInputProps({
            cell,
            column,
            row,
            table,
        })
        : columnDef.mantineEditTextInputProps;
    const textInputProps = Object.assign(Object.assign({}, mTableBodyCellEditTextInputProps), mcTableBodyCellEditTextInputProps);
    const mTableBodyCellEditSelectProps = mantineEditSelectProps instanceof Function
        ? mantineEditSelectProps({ cell, column, row, table })
        : mantineEditSelectProps;
    const mcTableBodyCellEditSelectProps = columnDef.mantineEditSelectProps instanceof Function
        ? columnDef.mantineEditSelectProps({
            cell,
            column,
            row,
            table,
        })
        : columnDef.mantineEditSelectProps;
    const selectProps = Object.assign(Object.assign({}, mTableBodyCellEditSelectProps), mcTableBodyCellEditSelectProps);
    const saveInputValueToRowCache = (newValue) => {
        //@ts-ignore
        row._valuesCache[column.id] = newValue;
        if (isCreating) {
            setCreatingRow(row);
        }
        else if (isEditing) {
            setEditingRow(row);
        }
    };
    const handleBlur = (event) => {
        var _a;
        (_a = textInputProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        saveInputValueToRowCache(value);
        setEditingCell(null);
    };
    const handleEnterKeyDown = (event) => {
        var _a, _b;
        (_a = textInputProps.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        if (event.key === 'Enter') {
            (_b = editInputRefs.current[cell.id]) === null || _b === void 0 ? void 0 : _b.blur();
        }
    };
    if (columnDef.Edit) {
        return (_a = columnDef.Edit) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table });
    }
    const commonProps = {
        disabled: (columnDef.enableEditing instanceof Function
            ? columnDef.enableEditing(row)
            : columnDef.enableEditing) === false,
        label: ['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? column.columnDef.header
            : undefined,
        name: cell.id,
        placeholder: !['modal', 'custom'].includes((isCreating ? createDisplayMode : editDisplayMode))
            ? columnDef.header
            : undefined,
        value,
        variant: editDisplayMode === 'table' ? 'unstyled' : 'default',
        onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, e);
        },
    };
    if (isSelectEdit) {
        return (
        // @ts-ignore
        jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { searchable: true, value: value, withinPortal: true }, selectProps, { onBlur: handleBlur, onChange: (value) => {
                var _a;
                (_a = selectProps.onChange) === null || _a === void 0 ? void 0 : _a.call(selectProps, value);
                setValue(value);
            }, onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = selectProps === null || selectProps === void 0 ? void 0 : selectProps.onClick) === null || _a === void 0 ? void 0 : _a.call(selectProps, e);
            }, ref: (node) => {
                if (node) {
                    editInputRefs.current[cell.id] = node;
                    if (selectProps.ref) {
                        selectProps.ref.current = node;
                    }
                }
            } })));
    }
    return (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { onKeyDown: handleEnterKeyDown, value: value !== null && value !== void 0 ? value : '' }, textInputProps, { onBlur: handleBlur, onChange: (event) => {
            var _a;
            (_a = textInputProps.onChange) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
            setValue(event.target.value);
        }, onClick: (event) => {
            var _a;
            event.stopPropagation();
            (_a = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.onClick) === null || _a === void 0 ? void 0 : _a.call(textInputProps, event);
        }, ref: (node) => {
            if (node) {
                editInputRefs.current[cell.id] = node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        } })));
};

const MRT_CopyButton = ({ cell, children, table, }) => {
    const { options: { localization, mantineCopyButtonProps }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const mTableBodyCellCopyButtonProps = mantineCopyButtonProps instanceof Function
        ? mantineCopyButtonProps({ cell, column, row, table })
        : mantineCopyButtonProps;
    const mcTableBodyCellCopyButtonProps = columnDef.mantineCopyButtonProps instanceof Function
        ? columnDef.mantineCopyButtonProps({
            cell,
            column,
            row,
            table,
        })
        : columnDef.mantineCopyButtonProps;
    const buttonProps = Object.assign(Object.assign({}, mTableBodyCellCopyButtonProps), mcTableBodyCellCopyButtonProps);
    return (jsxRuntime.jsx(core.CopyButton, { value: cell.getValue(), children: ({ copied, copy }) => {
            var _a;
            return (jsxRuntime.jsx(core.Tooltip, { color: copied ? 'green' : undefined, withinPortal: true, openDelay: 1000, label: (_a = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _a !== void 0 ? _a : (copied ? localization.copiedToClipboard : localization.clickToCopy), children: jsxRuntime.jsx(core.UnstyledButton, Object.assign({}, buttonProps, { onClick: (e) => {
                        e.stopPropagation();
                        copy();
                    }, sx: (theme) => (Object.assign({ backgroundColor: 'transparent', border: 'none', borderRadius: '4px', color: 'inherit', cursor: 'copy', fontFamily: 'inherit', fontSize: 'inherit', fontWeight: 'inherit', justifyContent: 'inherit', letterSpacing: 'inherit', margin: '-4px', minWidth: 'unset', padding: '4px', textAlign: 'inherit', textTransform: 'inherit', '&:active': {
                            transform: 'translateY(1px)',
                        }, '&:hover': {
                            backgroundColor: theme.fn.rgba(getPrimaryColor(theme), 0.1),
                        } }, ((buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx) instanceof Function
                        ? buttonProps.sx(theme)
                        : buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx))), title: undefined, children: children })) }));
        } }));
};

const allowedTypes = ['string', 'number'];
const allowedFilterVariants = ['text', 'autocomplete'];
const MRT_TableBodyCellValue = ({ cell, table, }) => {
    var _a, _b;
    const { getState, options: { enableFilterMatchHighlighting, mantineHighlightProps }, } = table;
    const { column, row } = cell;
    const { columnDef } = column;
    const { globalFilter, globalFilterFn } = getState();
    const filterValue = column.getFilterValue();
    const highlightProps = (mantineHighlightProps instanceof Function
        ? mantineHighlightProps({ cell, column, row, table })
        : mantineHighlightProps);
    let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell
        ? columnDef.AggregatedCell({
            cell,
            column,
            row,
            table,
        })
        : row.getIsGrouped() && !cell.getIsGrouped()
            ? null
            : cell.getIsGrouped() && columnDef.GroupedCell
                ? columnDef.GroupedCell({
                    cell,
                    column,
                    row,
                    table,
                })
                : undefined;
    const isGroupedValue = renderedCellValue !== undefined;
    if (!isGroupedValue) {
        renderedCellValue = cell.renderValue();
    }
    if (enableFilterMatchHighlighting &&
        columnDef.enableFilterMatchHighlighting !== false &&
        renderedCellValue &&
        allowedTypes.includes(typeof renderedCellValue) &&
        ((filterValue &&
            allowedTypes.includes(typeof filterValue) &&
            allowedFilterVariants.includes(columnDef.filterVariant)) ||
            (globalFilter &&
                allowedTypes.includes(typeof globalFilter) &&
                column.getCanGlobalFilter()))) {
        let highlight = ((_b = (_a = column.getFilterValue()) !== null && _a !== void 0 ? _a : globalFilter) !== null && _b !== void 0 ? _b : '').toString();
        if ((filterValue ? columnDef._filterFn : globalFilterFn) === 'fuzzy') {
            highlight = highlight.split(' ');
        }
        renderedCellValue = (jsxRuntime.jsx(core.Highlight, Object.assign({ highlightColor: "yellow.3", highlight: highlight }, highlightProps, { children: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString() })));
    }
    if (columnDef.Cell && !isGroupedValue) {
        renderedCellValue = columnDef.Cell({
            cell,
            renderedCellValue,
            column,
            row,
            table,
        });
    }
    return renderedCellValue;
};

const MRT_TableBodyCell = ({ cell, isStriped, measureElement, numRows, rowIndex, rowRef, table, virtualCell, }) => {
    var _a, _b, _c, _d;
    const theme = core.useMantineTheme();
    const { getState, options: { createDisplayMode, editDisplayMode, enableClickToCopy, enableColumnOrdering, enableEditing, enableGrouping, enableRowNumbers, layoutMode, mantineTableBodyCellProps, mantineSkeletonProps, rowNumberMode, }, refs: { editInputRefs }, setEditingCell, setHoveredColumn, } = table;
    const { creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons, } = getState();
    const { column, row } = cell;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const mTableCellBodyProps = mantineTableBodyCellProps instanceof Function
        ? mantineTableBodyCellProps({ cell, column, row, table })
        : mantineTableBodyCellProps;
    const mcTableCellBodyProps = columnDef.mantineTableBodyCellProps instanceof Function
        ? columnDef.mantineTableBodyCellProps({ cell, column, row, table })
        : columnDef.mantineTableBodyCellProps;
    const tableCellProps = Object.assign(Object.assign({}, mTableCellBodyProps), mcTableCellBodyProps);
    const skeletonProps = mantineSkeletonProps instanceof Function
        ? mantineSkeletonProps({ cell, column, row, table })
        : mantineSkeletonProps;
    const [skeletonWidth, setSkeletonWidth] = react.useState(100);
    react.useEffect(() => {
        if ((!isLoading && !showSkeletons) || skeletonWidth !== 100)
            return;
        const size = column.getSize();
        setSkeletonWidth(columnDefType === 'display'
            ? size / 2
            : Math.round(Math.random() * (size - size / 3) + size / 3));
    }, [isLoading, showSkeletons]);
    const draggingBorders = react.useMemo(() => {
        const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;
        const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;
        const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
        const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
        const isFirstColumn = getIsFirstColumn(column, table);
        const isLastColumn = getIsLastColumn(column, table);
        const isLastRow = rowIndex === numRows && numRows - 1;
        const borderStyle = isDraggingColumn || isDraggingRow
            ? `1px dashed ${theme.colors.gray[7]} !important`
            : isHoveredColumn || isHoveredRow
                ? `2px dashed ${getPrimaryColor(theme)} !important`
                : undefined;
        return borderStyle
            ? {
                borderLeft: isDraggingColumn ||
                    isHoveredColumn ||
                    ((isDraggingRow || isHoveredRow) && isFirstColumn)
                    ? borderStyle
                    : undefined,
                borderRight: isDraggingColumn ||
                    isHoveredColumn ||
                    ((isDraggingRow || isHoveredRow) && isLastColumn)
                    ? borderStyle
                    : undefined,
                borderBottom: isDraggingRow || isHoveredRow || isLastRow
                    ? borderStyle
                    : undefined,
                borderTop: isDraggingRow || isHoveredRow ? borderStyle : undefined,
            }
            : undefined;
    }, [draggingColumn, draggingRow, hoveredColumn, hoveredRow, rowIndex]);
    const isEditable = (enableEditing instanceof Function ? enableEditing(row) : enableEditing) &&
        (columnDef.enableEditing instanceof Function
            ? columnDef.enableEditing(row)
            : columnDef.enableEditing) !== false;
    const isEditing = isEditable &&
        !['modal', 'custom'].includes(editDisplayMode) &&
        (editDisplayMode === 'table' ||
            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id ||
            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) &&
        !row.getIsGrouped();
    const isCreating = isEditable && createDisplayMode === 'row' && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const handleDoubleClick = (event) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, event);
        if (isEditable && editDisplayMode === 'cell') {
            setEditingCell(cell);
            setTimeout(() => {
                var _a;
                const textField = editInputRefs.current[cell.id];
                if (textField) {
                    textField.focus();
                    (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);
                }
            }, 100);
        }
    };
    const handleDragEnter = (e) => {
        var _a;
        (_a = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a === void 0 ? void 0 : _a.call(tableCellProps, e);
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn) {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: "td", "data-index": virtualCell === null || virtualCell === void 0 ? void 0 : virtualCell.index, ref: (node) => {
            if (node) {
                measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);
            }
        } }, tableCellProps, { onDragEnter: handleDragEnter, onDoubleClick: handleDoubleClick, sx: (theme) => (Object.assign(Object.assign({ alignItems: layoutMode === 'grid' ? 'center' : undefined, cursor: isEditable && editDisplayMode === 'cell' ? 'pointer' : 'inherit', justifyContent: layoutMode === 'grid' ? tableCellProps.align : undefined, overflow: 'hidden', paddingLeft: column.id === 'mrt-row-expand'
                ? `${row.depth + 1}rem !important`
                : undefined, textOverflow: columnDefType !== 'display' ? 'ellipsis' : undefined, whiteSpace: density === 'xs' ? 'nowrap' : 'normal', zIndex: (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : column.getIsPinned() ? 1 : 0, '&:hover': {
                outline: isEditing &&
                    ['table', 'cell'].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : '') &&
                    columnDefType !== 'display'
                    ? `1px solid ${theme.colors.gray[7]}`
                    : undefined,
                outlineOffset: '-1px',
                textOverflow: 'clip',
            } }, getCommonCellStyles({
            column,
            isStriped,
            row,
            table,
            theme,
            tableCellProps,
        })), draggingBorders)), children: [jsxRuntime.jsx(jsxRuntime.Fragment, { children: cell.getIsPlaceholder() ? ((_b = (_a = columnDef.PlaceholderCell) === null || _a === void 0 ? void 0 : _a.call(columnDef, { cell, column, row, table })) !== null && _b !== void 0 ? _b : null) : (isLoading || showSkeletons) &&
                    [undefined, null].includes(cell.getValue()) ? (jsxRuntime.jsx(core.Skeleton, Object.assign({ height: 20, width: skeletonWidth }, skeletonProps))) : enableRowNumbers &&
                    rowNumberMode === 'static' &&
                    column.id === 'mrt-row-numbers' ? (rowIndex + 1) : columnDefType === 'display' &&
                    (['mrt-row-drag', 'mrt-row-expand', 'mrt-row-select'].includes(column.id) ||
                        !row.getIsGrouped()) ? ((_c = columnDef.Cell) === null || _c === void 0 ? void 0 : _c.call(columnDef, {
                    cell,
                    column,
                    row,
                    rowRef,
                    renderedCellValue: jsxRuntime.jsx(jsxRuntime.Fragment, { children: cell.getValue() }),
                    table,
                })) : isCreating || isEditing ? (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table })) : (enableClickToCopy || columnDef.enableClickToCopy) &&
                    columnDef.enableClickToCopy !== false ? (jsxRuntime.jsx(MRT_CopyButton, { cell: cell, table: table, children: jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table }) })) : (jsxRuntime.jsx(MRT_TableBodyCellValue, { cell: cell, table: table })) }), cell.getIsGrouped() && !columnDef.GroupedCell && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [" (", (_d = row.subRows) === null || _d === void 0 ? void 0 : _d.length, ")"] }))] })));
};
const Memo_MRT_TableBodyCell = react.memo(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);

const MRT_TableDetailPanel = ({ parentRowRef, row, rowIndex, table, virtualRow, }) => {
    const { getVisibleLeafColumns, getState, options: { layoutMode, mantineTableBodyRowProps, mantineDetailPanelProps, renderDetailPanel, }, } = table;
    const { isLoading } = getState();
    const tableRowProps = mantineTableBodyRowProps instanceof Function
        ? mantineTableBodyRowProps({
            isDetailPanel: true,
            row,
            staticRowIndex: rowIndex,
            table,
        })
        : mantineTableBodyRowProps;
    const tableCellProps = mantineDetailPanelProps instanceof Function
        ? mantineDetailPanelProps({ row, table })
        : mantineDetailPanelProps;
    return (jsxRuntime.jsx(core.Box, Object.assign({ component: "tr", className: "mantine-TableBodyCell-DetailPanel" }, tableRowProps, { sx: (theme) => {
            var _a, _b;
            return (Object.assign({ display: layoutMode === 'grid' ? 'flex' : 'table-row', position: virtualRow ? 'absolute' : undefined, top: virtualRow
                    ? `${(_b = (_a = parentRowRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px`
                    : undefined, transform: virtualRow
                    ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)`
                    : undefined, width: '100%', zIndex: virtualRow ? 2 : undefined }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function
                ? tableRowProps.sx(theme)
                : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx)));
        }, children: jsxRuntime.jsx(core.Box, Object.assign({ component: "td", className: "mantine-TableBodyCell-DetailPanel", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => (Object.assign({ backgroundColor: virtualRow
                    ? theme.fn.lighten(theme.colors.dark[7], 0.06)
                    : undefined, borderBottom: !row.getIsExpanded() ? 'none' : undefined, display: layoutMode === 'grid' ? 'flex' : 'table-cell', paddingBottom: row.getIsExpanded()
                    ? '16px !important'
                    : '0 !important', paddingTop: row.getIsExpanded() ? '16px !important' : '0 !important', transition: 'all 100ms ease-in-out', width: `${table.getTotalSize()}px` }, ((tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx) instanceof Function
                ? tableCellProps.sx(theme)
                : tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx))), children: renderDetailPanel && (jsxRuntime.jsx(core.Collapse, { in: row.getIsExpanded(), children: !isLoading && renderDetailPanel({ row, table }) })) })) })));
};

const MRT_TableBodyRow = ({ columnVirtualizer, enableHover, isStriped, measureElement, numRows, row, rowIndex, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, virtualRow, }) => {
    const { getState, options: { enableRowOrdering, layoutMode, memoMode, mantineTableBodyRowProps, renderDetailPanel, }, setHoveredRow, } = table;
    const { draggingColumn, draggingRow, editingCell, editingRow, hoveredRow } = getState();
    const tableRowProps = mantineTableBodyRowProps instanceof Function
        ? mantineTableBodyRowProps({ row, staticRowIndex: rowIndex, table })
        : mantineTableBodyRowProps;
    const handleDragEnter = (_e) => {
        if (enableRowOrdering && draggingRow) {
            setHoveredRow(row);
        }
    };
    const rowRef = react.useRef(null);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(core.Box, Object.assign({ component: "tr", "data-index": virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.index, onDragEnter: handleDragEnter, ref: (node) => {
                    if (node) {
                        rowRef.current = node;
                        measureElement === null || measureElement === void 0 ? void 0 : measureElement(node);
                    }
                } }, tableRowProps, { sx: (theme) => (Object.assign({ boxSizing: 'border-box', display: layoutMode === 'grid' ? 'flex' : 'table-row', opacity: (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id || (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id ? 0.5 : 1, position: virtualRow ? 'absolute' : undefined, top: virtualRow ? 0 : undefined, transition: virtualRow ? 'none' : 'all 100ms ease-in-out', width: '100%', '&:hover td': {
                        backgroundColor: enableHover !== false
                            ? row.getIsSelected()
                                ? theme.fn.rgba(getPrimaryColor(theme), 0.2)
                                : theme.colorScheme === 'dark'
                                    ? `${theme.fn.lighten(theme.colors.dark[7], 0.12)}`
                                    : `${theme.fn.darken(theme.white, 0.05)}`
                            : undefined,
                    } }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function
                    ? tableRowProps.sx(theme)
                    : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx))), style: Object.assign({ transform: virtualRow
                        ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)`
                        : undefined }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), children: [virtualPaddingLeft ? (jsxRuntime.jsx("td", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : row.getVisibleCells()).map((cellOrVirtualCell) => {
                        var _a, _b;
                        const cell = columnVirtualizer
                            ? row.getVisibleCells()[cellOrVirtualCell.index]
                            : cellOrVirtualCell;
                        const props = {
                            cell,
                            isStriped,
                            measureElement: columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement,
                            numRows,
                            rowIndex,
                            rowRef,
                            table,
                            virtualCell: columnVirtualizer
                                ? cellOrVirtualCell
                                : undefined,
                        };
                        return memoMode === 'cells' &&
                            cell.column.columnDef.columnDefType === 'data' &&
                            !draggingColumn &&
                            !draggingRow &&
                            (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id &&
                            (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (jsxRuntime.jsx(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_a = cell.getValue()) === null || _a === void 0 ? void 0 : _a.toString()))) : (jsxRuntime.jsx(MRT_TableBodyCell, Object.assign({}, props), cell.id + ((_b = cell.getValue) === null || _b === void 0 ? void 0 : _b.toString())));
                    }), virtualPaddingRight ? (jsxRuntime.jsx("td", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })), renderDetailPanel && !row.getIsGrouped() && (jsxRuntime.jsx(MRT_TableDetailPanel, { parentRowRef: rowRef, row: row, rowIndex: rowIndex, table: table, virtualRow: virtualRow }))] }));
};
const Memo_MRT_TableBodyRow = react.memo(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.rowIndex === next.rowIndex);

const MRT_TableBody = ({ columnVirtualizer, enableHover, isStriped, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {
    var _a, _b, _c;
    const { getRowModel, getPrePaginationRowModel, getState, options: { createDisplayMode, enableGlobalFilterRankedResults, enablePagination, enableRowVirtualization, layoutMode, localization, mantineTableBodyProps, manualExpanding, manualFiltering, manualGrouping, manualPagination, manualSorting, memoMode, renderEmptyRowsFallback, rowVirtualizerInstanceRef, rowVirtualizerProps, }, refs: { tableContainerRef, tablePaperRef }, } = table;
    const { creatingRow, columnFilters, density, expanded, globalFilter, pagination, sorting, } = getState();
    const tableBodyProps = mantineTableBodyProps instanceof Function
        ? mantineTableBodyProps({ table })
        : mantineTableBodyProps;
    const vProps = rowVirtualizerProps instanceof Function
        ? rowVirtualizerProps({ table })
        : rowVirtualizerProps;
    const shouldRankRows = react.useMemo(() => getCanRankRows(table) &&
        !Object.values(sorting).some(Boolean) &&
        globalFilter, [
        enableGlobalFilterRankedResults,
        expanded,
        globalFilter,
        manualExpanding,
        manualFiltering,
        manualGrouping,
        manualSorting,
        sorting,
    ]);
    const rows = react.useMemo(() => {
        if (!shouldRankRows)
            return getRowModel().rows;
        const rankedRows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
        if (enablePagination && !manualPagination) {
            const start = pagination.pageIndex * pagination.pageSize;
            return rankedRows.slice(start, start + pagination.pageSize);
        }
        return rankedRows;
    }, [
        shouldRankRows,
        shouldRankRows ? getPrePaginationRowModel().rows : getRowModel().rows,
        pagination.pageIndex,
        pagination.pageSize,
    ]);
    const rowVirtualizer = enableRowVirtualization
        ? reactVirtual.useVirtualizer(Object.assign({ count: rows.length, estimateSize: () => density === 'xs' ? 42.7 : density === 'md' ? 54.7 : 70.7, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== 'undefined' &&
                navigator.userAgent.indexOf('Firefox') === -1
                ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height
                : undefined, overscan: 4 }, vProps))
        : undefined;
    if (rowVirtualizerInstanceRef && rowVirtualizer) {
        rowVirtualizerInstanceRef.current = rowVirtualizer;
    }
    const virtualRows = rowVirtualizer
        ? rowVirtualizer.getVirtualItems()
        : undefined;
    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: "tbody" }, tableBodyProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-row-group', height: rowVirtualizer
                ? `${rowVirtualizer.getTotalSize()}px`
                : 'inherit', minHeight: !rows.length ? '100px' : undefined, position: 'relative' }, ((tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx) instanceof Function
            ? tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx(theme)
            : tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx))), children: [creatingRow && createDisplayMode === 'row' && (jsxRuntime.jsx(MRT_TableBodyRow, { table: table, row: creatingRow, rowIndex: -1 })), !rows.length ? (jsxRuntime.jsx("tr", { style: { display: layoutMode === 'grid' ? 'grid' : 'table-row' }, children: jsxRuntime.jsx("td", { colSpan: table.getVisibleLeafColumns().length, style: { display: layoutMode === 'grid' ? 'grid' : 'table-cell' }, children: (_a = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsx(core.Text, { sx: {
                            color: 'gray',
                            fontStyle: 'italic',
                            maxWidth: `min(100vw, ${(_c = (_b = tablePaperRef.current) === null || _b === void 0 ? void 0 : _b.clientWidth) !== null && _c !== void 0 ? _c : 360}px)`,
                            paddingTop: '2rem',
                            paddingBottom: '2rem',
                            textAlign: 'center',
                            width: '100%',
                        }, children: globalFilter || columnFilters.length
                            ? localization.noResultsFound
                            : localization.noRecordsToDisplay })) }) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, rowIndex) => {
                    const row = rowVirtualizer
                        ? rows[rowOrVirtualRow.index]
                        : rowOrVirtualRow;
                    const props = {
                        columnVirtualizer,
                        enableHover,
                        isStriped,
                        measureElement: rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement,
                        numRows: rows.length,
                        row,
                        rowIndex: rowVirtualizer ? rowOrVirtualRow.index : rowIndex,
                        table,
                        virtualColumns,
                        virtualPaddingLeft,
                        virtualPaddingRight,
                        virtualRow: rowVirtualizer
                            ? rowOrVirtualRow
                            : undefined,
                    };
                    return memoMode === 'rows' ? (jsxRuntime.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id || `mrt-${row.index}`)) : (jsxRuntime.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id || `mrt-${row.index}`));
                }) }))] })));
};
const Memo_MRT_TableBody = react.memo(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);

const MRT_GrabHandleButton = ({ actionIconProps, onDragEnd, onDragStart, table, }) => {
    var _a, _b;
    const { options: { icons: { IconGripHorizontal }, localization, }, } = table;
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : localization.move, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ draggable: "true", size: "sm", "aria-label": (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _b !== void 0 ? _b : localization.move }, actionIconProps, { onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, e);
            }, onDragStart: onDragStart, onDragEnd: onDragEnd, sx: (theme) => (Object.assign({ cursor: 'grab', margin: '0 -0.16px', opacity: 0.5, padding: '2px', transition: 'opacity 100ms ease-in-out', '&:hover': {
                    backgroundColor: 'transparent',
                    opacity: 1,
                }, '&:active': {
                    cursor: 'grabbing',
                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function
                ? actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx(theme)
                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: jsxRuntime.jsx(IconGripHorizontal, {}) })) }));
};

const MRT_TableBodyRowGrabHandle = ({ row, rowRef, table, }) => {
    const { options: { mantineRowDragHandleProps }, } = table;
    const actionIconProps = mantineRowDragHandleProps instanceof Function
        ? mantineRowDragHandleProps({ row, table })
        : mantineRowDragHandleProps;
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        event.dataTransfer.setDragImage(rowRef.current, 0, 0);
        table.setDraggingRow(row);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        table.setDraggingRow(null);
        table.setHoveredRow(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));
};

const MRT_ExpandAllButton = ({ table, }) => {
    var _a, _b;
    const { getIsAllRowsExpanded, getIsSomeRowsExpanded, getCanSomeRowsExpand, getState, options: { icons: { IconChevronsDown }, localization, mantineExpandAllButtonProps, renderDetailPanel, }, toggleAllRowsExpanded, } = table;
    const { density, isLoading } = getState();
    const actionIconProps = mantineExpandAllButtonProps instanceof Function
        ? mantineExpandAllButtonProps({ table })
        : mantineExpandAllButtonProps;
    const isAllRowsExpanded = getIsAllRowsExpanded();
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isAllRowsExpanded)
            ? localization.collapseAll
            : localization.expandAll, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expandAll, disabled: isLoading || (!renderDetailPanel && !getCanSomeRowsExpand()), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, actionIconProps, { sx: (theme) => (Object.assign({ marginLeft: density === 'xl' ? '-6px' : density === 'md' ? '0' : '6px', opacity: 0.8, '&:disabled': {
                    backgroundColor: 'transparent',
                    border: 'none',
                }, '&:hover': {
                    opacity: 1,
                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function
                ? actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx(theme)
                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronsDown, { style: {
                    transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,
                    transition: 'transform 100ms',
                } })) })) }));
};

const MRT_ExpandButton = ({ row, table, }) => {
    var _a, _b;
    const { options: { icons: { IconChevronDown }, localization, mantineExpandButtonProps, renderDetailPanel, }, } = table;
    const actionIconProps = mantineExpandButtonProps instanceof Function
        ? mantineExpandButtonProps({ table, row })
        : mantineExpandButtonProps;
    const canExpand = row.getCanExpand();
    const isExpanded = row.getIsExpanded();
    const handleToggleExpand = (event) => {
        var _a;
        event.stopPropagation();
        row.toggleExpanded();
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onClick) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, disabled: !canExpand && !renderDetailPanel, openDelay: 1000, label: ((_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _a !== void 0 ? _a : isExpanded)
            ? localization.collapse
            : localization.expand, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.expand, disabled: !canExpand && !renderDetailPanel }, actionIconProps, { onClick: handleToggleExpand, sx: (theme) => (Object.assign({ opacity: 0.8, '&:disabled': {
                    backgroundColor: 'transparent',
                    border: 'none',
                }, '&:hover': {
                    opacity: 1,
                } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function
                ? actionIconProps.sx(theme)
                : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), title: undefined, children: (_b = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.children) !== null && _b !== void 0 ? _b : (jsxRuntime.jsx(IconChevronDown, { style: {
                    transform: `rotate(${!canExpand && !renderDetailPanel ? -90 : isExpanded ? -180 : 0}deg)`,
                    transition: 'transform 100ms',
                } })) })) }));
};

const MRT_RowActionMenu = ({ handleEdit, row, table, }) => {
    const { options: { editDisplayMode, enableEditing, icons: { IconEdit, IconDots }, localization, positionActionsColumn, renderRowActionMenuItems, }, } = table;
    return (jsxRuntime.jsxs(core.Menu, { position: positionActionsColumn === 'first'
            ? 'bottom-start'
            : positionActionsColumn === 'last'
                ? 'bottom-end'
                : undefined, closeOnItemClick: true, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.rowActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.rowActions, onClick: (event) => event.stopPropagation(), size: "sm", children: jsxRuntime.jsx(IconDots, {}) }) }) }), jsxRuntime.jsxs(core.Menu.Dropdown, { onClick: (event) => event.stopPropagation(), children: [enableEditing && editDisplayMode !== 'table' && (jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconEdit, {}), onClick: handleEdit, children: localization.edit })), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
                        row,
                        table,
                    })] })] }));
};

const MRT_EditActionButtons = ({ row, table, variant = 'icon', }) => {
    const { getState, options: { icons: { IconCircleX, IconDeviceFloppy }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowSave, onEditingRowCancel, }, refs: { editInputRefs }, setCreatingRow, setEditingRow, } = table;
    const { creatingRow, editingRow, isSaving } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleCancel = () => {
        if (isCreating) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else if (isEditing) {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
    };
    const handleSubmitRow = () => {
        var _a;
        //look for auto-filled input values
        (_a = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current)
            .filter((inputRef) => { var _a, _b; return row.id === ((_b = (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a === void 0 ? void 0 : _a.split('_')) === null || _b === void 0 ? void 0 : _b[0]); })) === null || _a === void 0 ? void 0 : _a.forEach((input) => {
            if (input.value !== undefined &&
                Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {
                // @ts-ignore
                row._valuesCache[input.name] = input.value;
            }
        });
        if (isCreating)
            onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({
                exitCreatingMode: () => setCreatingRow(null),
                row,
                table,
                values: row._valuesCache,
            });
        else if (isEditing) {
            onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
                exitEditingMode: () => setEditingRow(null),
                row,
                table,
                values: row === null || row === void 0 ? void 0 : row._valuesCache,
            });
        }
    };
    return (jsxRuntime.jsx(core.Box, { onClick: (e) => e.stopPropagation(), sx: { display: 'flex', gap: '12px' }, children: variant === 'icon' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.cancel, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.cancel, onClick: handleCancel, children: jsxRuntime.jsx(IconCircleX, {}) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.save, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.save, color: "blue", onClick: handleSubmitRow, loading: isSaving, children: jsxRuntime.jsx(IconDeviceFloppy, {}) }) })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Button, { onClick: handleCancel, variant: "subtle", children: localization.cancel }), jsxRuntime.jsx(core.Button, { onClick: handleSubmitRow, variant: "filled", loading: isSaving, children: localization.save })] })) }));
};

const MRT_ToggleRowActionMenuButton = ({ cell, row, table, }) => {
    const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { IconEdit }, localization, renderRowActionMenuItems, renderRowActions, }, setEditingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
    const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
    const handleStartEditMode = (event) => {
        event.stopPropagation();
        setEditingRow(Object.assign({}, row));
    };
    const showEditActionButtons = (isCreating && createDisplayMode === 'row') ||
        (isEditing && editDisplayMode === 'row');
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: renderRowActions && !showEditActionButtons ? (renderRowActions({ cell, row, table })) : showEditActionButtons ? (jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table })) : !renderRowActionMenuItems &&
            (enableEditing instanceof Function
                ? enableEditing(row)
                : enableEditing) ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, position: "right", label: localization.edit, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.edit, disabled: !!editingRow && editingRow.id !== row.id, onClick: handleStartEditMode, sx: {
                    opacity: 0.8,
                    '&:hover': {
                        opacity: 1,
                    },
                    '&:disabled': {
                        backgroundColor: 'transparent',
                        border: 'none',
                    },
                }, children: jsxRuntime.jsx(IconEdit, {}) }) })) : renderRowActionMenuItems ? (jsxRuntime.jsx(MRT_RowActionMenu, { handleEdit: handleStartEditMode, row: row, table: table })) : null }));
};

const MRT_SelectCheckbox = ({ row, selectAll, table, }) => {
    var _a;
    const { getState, options: { enableMultiRowSelection, localization, mantineSelectAllCheckboxProps, mantineSelectCheckboxProps, selectAllMode, selectDisplayMode, }, } = table;
    const { density, isLoading } = getState();
    const checkboxProps = !row
        ? mantineSelectAllCheckboxProps instanceof Function
            ? mantineSelectAllCheckboxProps({ table })
            : mantineSelectAllCheckboxProps
        : mantineSelectCheckboxProps instanceof Function
            ? mantineSelectCheckboxProps({ row, table })
            : mantineSelectCheckboxProps;
    const allRowsSelected = selectAll
        ? selectAllMode === 'page'
            ? table.getIsAllPageRowsSelected()
            : table.getIsAllRowsSelected()
        : undefined;
    const commonProps = Object.assign(Object.assign({ 'aria-label': selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow, checked: selectAll ? allRowsSelected : row === null || row === void 0 ? void 0 : row.getIsSelected(), disabled: isLoading || (row && !row.getCanSelect()), onChange: row
            ? row.getToggleSelectedHandler()
            : selectAllMode === 'all'
                ? table.getToggleAllRowsSelectedHandler()
                : table.getToggleAllPageRowsSelectedHandler(), size: density === 'xs' ? 'sm' : 'md' }, checkboxProps), { onClick: (e) => {
            var _a;
            e.stopPropagation();
            (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
        }, title: undefined });
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _a !== void 0 ? _a : (selectAll
            ? localization.toggleSelectAll
            : localization.toggleSelectRow), children: jsxRuntime.jsx("span", { children: selectDisplayMode === 'switch' ? (jsxRuntime.jsx(core.Switch, Object.assign({}, commonProps))) : selectDisplayMode === 'radio' ||
                enableMultiRowSelection === false ? (jsxRuntime.jsx(core.Radio, Object.assign({}, commonProps))) : (jsxRuntime.jsx(core.Checkbox, Object.assign({ indeterminate: selectAll
                    ? table.getIsSomeRowsSelected() && !allRowsSelected
                    : row === null || row === void 0 ? void 0 : row.getIsSomeSelected() }, commonProps))) }) }));
};

const useMRT_DisplayColumns = ({ creatingRow, columnOrder, grouping, tableOptions, }) => {
    var _a, _b;
    return react.useMemo(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        return [
            ((_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnOrder) !== null && _b !== void 0 ? _b : columnOrder).includes('mrt-row-drag') && Object.assign(Object.assign(Object.assign({ Cell: ({ row, rowRef, table }) => (jsxRuntime.jsx(MRT_TableBodyRowGrabHandle, { row: row, rowRef: rowRef, table: table })), header: tableOptions.localization.move, size: 60 }, tableOptions.defaultDisplayColumn), (_c = tableOptions.displayColumnDefOptions) === null || _c === void 0 ? void 0 : _c['mrt-row-drag']), { id: 'mrt-row-drag' }),
            (((_e = (_d = tableOptions.state) === null || _d === void 0 ? void 0 : _d.columnOrder) !== null && _e !== void 0 ? _e : columnOrder).includes('mrt-row-actions') ||
                (creatingRow && tableOptions.createDisplayMode === 'row')) && Object.assign(Object.assign(Object.assign({ Cell: ({ cell, row, table }) => (jsxRuntime.jsx(MRT_ToggleRowActionMenuButton, { cell: cell, row: row, table: table })), header: tableOptions.localization.actions, size: 70 }, tableOptions.defaultDisplayColumn), (_f = tableOptions.displayColumnDefOptions) === null || _f === void 0 ? void 0 : _f['mrt-row-actions']), { id: 'mrt-row-actions' }),
            ((_h = (_g = tableOptions.state) === null || _g === void 0 ? void 0 : _g.columnOrder) !== null && _h !== void 0 ? _h : columnOrder).includes('mrt-row-expand') &&
                showExpandColumn(tableOptions, (_k = (_j = tableOptions.state) === null || _j === void 0 ? void 0 : _j.grouping) !== null && _k !== void 0 ? _k : grouping) && Object.assign(Object.assign(Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_ExpandButton, { row: row, table: table })), Header: tableOptions.enableExpandAll
                    ? ({ table }) => jsxRuntime.jsx(MRT_ExpandAllButton, { table: table })
                    : null, header: tableOptions.localization.expand, size: 60 }, tableOptions.defaultDisplayColumn), (_l = tableOptions.displayColumnDefOptions) === null || _l === void 0 ? void 0 : _l['mrt-row-expand']), { id: 'mrt-row-expand' }),
            ((_o = (_m = tableOptions.state) === null || _m === void 0 ? void 0 : _m.columnOrder) !== null && _o !== void 0 ? _o : columnOrder).includes('mrt-row-select') && Object.assign(Object.assign(Object.assign({ Cell: ({ row, table }) => (jsxRuntime.jsx(MRT_SelectCheckbox, { row: row, table: table })), Header: tableOptions.enableSelectAll &&
                    tableOptions.enableMultiRowSelection
                    ? ({ table }) => jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })
                    : null, header: tableOptions.localization.select, size: 60 }, tableOptions.defaultDisplayColumn), (_p = tableOptions.displayColumnDefOptions) === null || _p === void 0 ? void 0 : _p['mrt-row-select']), { id: 'mrt-row-select' }),
            ((_r = (_q = tableOptions.state) === null || _q === void 0 ? void 0 : _q.columnOrder) !== null && _r !== void 0 ? _r : columnOrder).includes('mrt-row-numbers') && Object.assign(Object.assign(Object.assign({ Cell: ({ row }) => row.index + 1, Header: () => tableOptions.localization.rowNumber, header: tableOptions.localization.rowNumbers, size: 60 }, tableOptions.defaultDisplayColumn), (_s = tableOptions.displayColumnDefOptions) === null || _s === void 0 ? void 0 : _s['mrt-row-numbers']), { id: 'mrt-row-numbers' }),
        ].filter(Boolean);
    }, [
        columnOrder,
        grouping,
        tableOptions.displayColumnDefOptions,
        tableOptions.editDisplayMode,
        tableOptions.enableColumnDragging,
        tableOptions.enableColumnFilterModes,
        tableOptions.enableColumnOrdering,
        tableOptions.enableEditing,
        tableOptions.enableExpandAll,
        tableOptions.enableExpanding,
        tableOptions.enableGrouping,
        tableOptions.enableRowActions,
        tableOptions.enableRowDragging,
        tableOptions.enableRowNumbers,
        tableOptions.enableRowOrdering,
        tableOptions.enableRowSelection,
        tableOptions.enableSelectAll,
        tableOptions.localization,
        tableOptions.positionActionsColumn,
        tableOptions.renderDetailPanel,
        tableOptions.renderRowActionMenuItems,
        tableOptions.renderRowActions,
        (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnOrder,
        (_b = tableOptions.state) === null || _b === void 0 ? void 0 : _b.grouping,
    ]);
};

const useMRT_Effects = (table) => {
    const { getState, options: { enablePagination, rowCount }, } = table;
    const { globalFilter, isFullScreen, pagination, sorting, isLoading, showSkeletons, } = getState();
    const isMounted = react.useRef(false);
    const initialBodyHeight = react.useRef();
    const previousTop = react.useRef();
    react.useEffect(() => {
        if (typeof window !== 'undefined') {
            initialBodyHeight.current = document.body.style.height;
        }
    }, []);
    react.useEffect(() => {
        if (isMounted && typeof window !== 'undefined') {
            if (isFullScreen) {
                previousTop.current = document.body.getBoundingClientRect().top; //save scroll position
                document.body.style.height = '100vh'; //hide page scrollbars when table is in full screen mode
            }
            else {
                document.body.style.height = initialBodyHeight.current;
                if (!previousTop.current)
                    return;
                //restore scroll position
                window.scrollTo({
                    top: -1 * previousTop.current,
                    behavior: 'instant',
                });
            }
        }
        isMounted.current = true;
    }, [isFullScreen]);
    //if page index is out of bounds, set it to the last page
    react.useEffect(() => {
        if (!enablePagination || isLoading || showSkeletons)
            return;
        const { pageIndex, pageSize } = pagination;
        const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : table.getPrePaginationRowModel().rows.length;
        const firstVisibleRowIndex = pageIndex * pageSize;
        if (firstVisibleRowIndex > totalRowCount) {
            table.setPageIndex(Math.floor(totalRowCount / pageSize));
        }
    }, [rowCount, table.getPrePaginationRowModel().rows.length]);
    //turn off sort when global filter is looking for ranked results
    const appliedSort = react.useRef(sorting);
    react.useEffect(() => {
        if (sorting.length) {
            appliedSort.current = sorting;
        }
    }, [sorting]);
    react.useEffect(() => {
        if (!getCanRankRows(table))
            return;
        if (globalFilter) {
            table.setSorting([]);
        }
        else {
            table.setSorting(() => appliedSort.current || []);
        }
    }, [globalFilter]);
};

const useMRT_TableInstance = (tableOptions) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
    const bottomToolbarRef = react.useRef(null);
    const editInputRefs = react.useRef({});
    const filterInputRefs = react.useRef({});
    const searchInputRef = react.useRef(null);
    const tableContainerRef = react.useRef(null);
    const tableHeadCellRefs = react.useRef({});
    const tablePaperRef = react.useRef(null);
    const topToolbarRef = react.useRef(null);
    const initialState = react.useMemo(() => {
        var _a, _b, _c;
        const initState = (_a = tableOptions.initialState) !== null && _a !== void 0 ? _a : {};
        initState.columnOrder =
            (_b = initState.columnOrder) !== null && _b !== void 0 ? _b : getDefaultColumnOrderIds(tableOptions);
        initState.globalFilterFn = (_c = tableOptions.globalFilterFn) !== null && _c !== void 0 ? _c : 'fuzzy';
        return initState;
    }, []);
    const [creatingRow, _setCreatingRow] = react.useState((_a = initialState.creatingRow) !== null && _a !== void 0 ? _a : null);
    const [columnFilterFns, setColumnFilterFns] = react.useState(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => {
        var _a, _b, _c, _d;
        return ({
            [getColumnId(col)]: col.filterFn instanceof Function
                ? (_a = col.filterFn.name) !== null && _a !== void 0 ? _a : 'custom'
                : (_d = (_b = col.filterFn) !== null && _b !== void 0 ? _b : (_c = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c === void 0 ? void 0 : _c[getColumnId(col)]) !== null && _d !== void 0 ? _d : getDefaultColumnFilterFn(col),
        });
    })));
    const [columnOrder, setColumnOrder] = react.useState((_b = initialState.columnOrder) !== null && _b !== void 0 ? _b : []);
    const [density, setDensity] = react.useState((_c = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _c !== void 0 ? _c : 'md');
    const [draggingColumn, setDraggingColumn] = react.useState((_d = initialState.draggingColumn) !== null && _d !== void 0 ? _d : null);
    const [draggingRow, setDraggingRow] = react.useState((_e = initialState.draggingRow) !== null && _e !== void 0 ? _e : null);
    const [editingCell, setEditingCell] = react.useState((_f = initialState.editingCell) !== null && _f !== void 0 ? _f : null);
    const [editingRow, setEditingRow] = react.useState((_g = initialState.editingRow) !== null && _g !== void 0 ? _g : null);
    const [globalFilterFn, setGlobalFilterFn] = react.useState((_h = initialState.globalFilterFn) !== null && _h !== void 0 ? _h : 'fuzzy');
    const [grouping, setGrouping] = react.useState((_j = initialState.grouping) !== null && _j !== void 0 ? _j : []);
    const [hoveredColumn, setHoveredColumn] = react.useState((_k = initialState.hoveredColumn) !== null && _k !== void 0 ? _k : null);
    const [hoveredRow, setHoveredRow] = react.useState((_l = initialState.hoveredRow) !== null && _l !== void 0 ? _l : null);
    const [isFullScreen, setIsFullScreen] = react.useState((_m = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _m !== void 0 ? _m : false);
    const [showAlertBanner, setShowAlertBanner] = react.useState((_p = (_o = tableOptions.initialState) === null || _o === void 0 ? void 0 : _o.showAlertBanner) !== null && _p !== void 0 ? _p : false);
    const [showColumnFilters, setShowColumnFilters] = react.useState((_q = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _q !== void 0 ? _q : false);
    const [showGlobalFilter, setShowGlobalFilter] = react.useState((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _r !== void 0 ? _r : false);
    const [showToolbarDropZone, setShowToolbarDropZone] = react.useState((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _s !== void 0 ? _s : false);
    const displayColumns = useMRT_DisplayColumns({
        columnOrder,
        creatingRow,
        grouping,
        tableOptions,
    });
    const columnDefs = react.useMemo(() => {
        var _a, _b, _c;
        return prepareColumns({
            aggregationFns: tableOptions.aggregationFns,
            columnDefs: [...displayColumns, ...tableOptions.columns],
            columnFilterFns: (_b = (_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.columnFilterFns) !== null && _b !== void 0 ? _b : columnFilterFns,
            defaultDisplayColumn: (_c = tableOptions.defaultDisplayColumn) !== null && _c !== void 0 ? _c : {},
            filterFns: tableOptions.filterFns,
            sortingFns: tableOptions.sortingFns,
        });
    }, [
        columnFilterFns,
        displayColumns,
        tableOptions.columns,
        (_t = tableOptions.state) === null || _t === void 0 ? void 0 : _t.columnFilterFns,
    ]);
    const data = react.useMemo(() => {
        var _a, _b, _c, _d, _e;
        return (((_a = tableOptions.state) === null || _a === void 0 ? void 0 : _a.isLoading) || ((_b = tableOptions.state) === null || _b === void 0 ? void 0 : _b.showSkeletons)) &&
            !tableOptions.data.length
            ? [
                ...Array(((_d = (_c = tableOptions.state) === null || _c === void 0 ? void 0 : _c.pagination) === null || _d === void 0 ? void 0 : _d.pageSize) ||
                    ((_e = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) === null || _e === void 0 ? void 0 : _e.pageSize) ||
                    10).fill(null),
            ].map(() => Object.assign({}, ...getAllLeafColumnDefs(tableOptions.columns).map((col) => ({
                [getColumnId(col)]: null,
            }))))
            : tableOptions.data;
    }, [
        tableOptions.data,
        (_u = tableOptions.state) === null || _u === void 0 ? void 0 : _u.isLoading,
        (_v = tableOptions.state) === null || _v === void 0 ? void 0 : _v.showSkeletons,
    ]);
    //@ts-ignore
    const table = reactTable.useReactTable(Object.assign(Object.assign({ getCoreRowModel: reactTable.getCoreRowModel(), getExpandedRowModel: tableOptions.enableExpanding || tableOptions.enableGrouping
            ? reactTable.getExpandedRowModel()
            : undefined, getFacetedMinMaxValues: tableOptions.enableFacetedValues
            ? reactTable.getFacetedMinMaxValues()
            : undefined, getFacetedRowModel: tableOptions.enableFacetedValues
            ? reactTable.getFacetedRowModel()
            : undefined, getFacetedUniqueValues: tableOptions.enableFacetedValues
            ? reactTable.getFacetedUniqueValues()
            : undefined, getFilteredRowModel: tableOptions.enableColumnFilters ||
            tableOptions.enableGlobalFilter ||
            tableOptions.enableFilters
            ? reactTable.getFilteredRowModel()
            : undefined, getGroupedRowModel: tableOptions.enableGrouping
            ? reactTable.getGroupedRowModel()
            : undefined, getPaginationRowModel: tableOptions.enablePagination
            ? reactTable.getPaginationRowModel()
            : undefined, getSortedRowModel: tableOptions.enableSorting
            ? reactTable.getSortedRowModel()
            : undefined, onColumnOrderChange: setColumnOrder, onGroupingChange: setGrouping, getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows }, tableOptions), { 
        //@ts-ignore
        columns: columnDefs, data, globalFilterFn: (_w = tableOptions.filterFns) === null || _w === void 0 ? void 0 : _w[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : 'fuzzy'], initialState, state: Object.assign({ creatingRow,
            columnFilterFns,
            columnOrder,
            density,
            draggingColumn,
            draggingRow,
            editingCell,
            editingRow,
            globalFilterFn,
            grouping,
            hoveredColumn,
            hoveredRow,
            isFullScreen,
            showAlertBanner,
            showColumnFilters,
            showGlobalFilter,
            showToolbarDropZone }, tableOptions.state) }));
    // @ts-ignore
    table.refs = {
        // @ts-ignore
        bottomToolbarRef,
        editInputRefs,
        filterInputRefs,
        // @ts-ignore
        searchInputRef,
        // @ts-ignore
        tableContainerRef,
        tableHeadCellRefs,
        // @ts-ignore
        tablePaperRef,
        // @ts-ignore
        topToolbarRef,
    };
    const setCreatingRow = (row) => {
        var _a, _b;
        let _row = row;
        if (row === true) {
            _row = createRow(table);
        }
        (_b = (_a = tableOptions === null || tableOptions === void 0 ? void 0 : tableOptions.onCreatingRowChange) === null || _a === void 0 ? void 0 : _a.call(tableOptions, _row)) !== null && _b !== void 0 ? _b : _setCreatingRow(_row);
    };
    table.setCreatingRow = setCreatingRow;
    table.setColumnFilterFns =
        (_x = tableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;
    table.setDensity = (_y = tableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;
    table.setDraggingColumn =
        (_z = tableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;
    table.setDraggingRow = (_0 = tableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;
    table.setEditingCell = (_1 = tableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;
    table.setEditingRow = (_2 = tableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;
    table.setGlobalFilterFn =
        (_3 = tableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;
    table.setHoveredColumn =
        (_4 = tableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;
    table.setHoveredRow = (_5 = tableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;
    table.setIsFullScreen = (_6 = tableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;
    table.setShowAlertBanner =
        (_7 = tableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;
    table.setShowColumnFilters =
        (_8 = tableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;
    table.setShowGlobalFilter =
        (_9 = tableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;
    table.setShowToolbarDropZone =
        (_10 = tableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;
    useMRT_Effects(table);
    return table;
};

const useMantineReactTable = (tableOptions) => {
    const parsedTableOptions = useMRT_TableOptions(tableOptions);
    const tableInstance = useMRT_TableInstance(parsedTableOptions);
    return tableInstance;
};

const mrtFilterOptions = (localization) => [
    {
        option: 'fuzzy',
        symbol: '',
        label: localization.filterFuzzy,
        divider: false,
    },
    {
        option: 'contains',
        symbol: '*',
        label: localization.filterContains,
        divider: false,
    },
    {
        option: 'startsWith',
        symbol: 'a',
        label: localization.filterStartsWith,
        divider: false,
    },
    {
        option: 'endsWith',
        symbol: 'z',
        label: localization.filterEndsWith,
        divider: true,
    },
    {
        option: 'equals',
        symbol: '=',
        label: localization.filterEquals,
        divider: false,
    },
    {
        option: 'notEquals',
        symbol: '',
        label: localization.filterNotEquals,
        divider: true,
    },
    {
        option: 'between',
        symbol: '',
        label: localization.filterBetween,
        divider: false,
    },
    {
        option: 'betweenInclusive',
        symbol: '',
        label: localization.filterBetweenInclusive,
        divider: true,
    },
    {
        option: 'greaterThan',
        symbol: '>',
        label: localization.filterGreaterThan,
        divider: false,
    },
    {
        option: 'greaterThanOrEqualTo',
        symbol: '',
        label: localization.filterGreaterThanOrEqualTo,
        divider: false,
    },
    {
        option: 'lessThan',
        symbol: '<',
        label: localization.filterLessThan,
        divider: false,
    },
    {
        option: 'lessThanOrEqualTo',
        symbol: '',
        label: localization.filterLessThanOrEqualTo,
        divider: true,
    },
    {
        option: 'empty',
        symbol: '',
        label: localization.filterEmpty,
        divider: false,
    },
    {
        option: 'notEmpty',
        symbol: '!',
        label: localization.filterNotEmpty,
        divider: false,
    },
];
const rangeModes = ['between', 'betweenInclusive', 'inNumberRange'];
const emptyModes = ['empty', 'notEmpty'];
const arrModes = ['arrIncludesSome', 'arrIncludesAll', 'arrIncludes'];
const rangeVariants = ['range-slider', 'date-range', 'range'];
const MRT_FilterOptionMenu = ({ header, onSelect, table, }) => {
    var _a, _b, _c, _d;
    const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems, }, setColumnFilterFns, setGlobalFilterFn, } = table;
    const { globalFilterFn } = getState();
    const { column } = header !== null && header !== void 0 ? header : {};
    const { columnDef } = column !== null && column !== void 0 ? column : {};
    const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();
    let allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {
        allowedColumnFilterOptions = [
            ...rangeModes,
            ...(allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []),
        ].filter((option) => rangeModes.includes(option));
    }
    const internalFilterOptions = react.useMemo(() => mrtFilterOptions(localization).filter((filterOption) => columnDef
        ? allowedColumnFilterOptions === undefined ||
            (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption.option))
        : (!globalFilterModeOptions ||
            globalFilterModeOptions.includes(filterOption.option)) &&
            ['fuzzy', 'contains', 'startsWith'].includes(filterOption.option)), []);
    const handleSelectFilterMode = (option) => {
        var _a;
        const prevFilterMode = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a !== void 0 ? _a : '';
        if (!header || !column) {
            // global filter mode
            setGlobalFilterFn(option);
        }
        else if (option !== prevFilterMode) {
            // column filter mode
            setColumnFilterFns((prev) => (Object.assign(Object.assign({}, prev), { [header.id]: option })));
            // reset filter value and/or perform new filter render
            if (emptyModes.includes(option)) {
                // will now be empty/notEmpty filter mode
                if (currentFilterValue !== ' ' &&
                    !emptyModes.includes(prevFilterMode)) {
                    column.setFilterValue(' ');
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === 'multi-select' ||
                arrModes.includes(option)) {
                // will now be array filter mode
                if (currentFilterValue instanceof String ||
                    (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
                    column.setFilterValue([]);
                }
                else if (currentFilterValue) {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) ||
                rangeModes.includes(option)) {
                // will now be range filter mode
                if (!Array.isArray(currentFilterValue) ||
                    (!(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === '')) &&
                        !rangeModes.includes(prevFilterMode))) {
                    column.setFilterValue(['', '']);
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
            else {
                // will now be single value filter mode
                if (Array.isArray(currentFilterValue)) {
                    column.setFilterValue('');
                }
                else {
                    column.setFilterValue(currentFilterValue); // perform new filter render
                }
            }
        }
        onSelect === null || onSelect === void 0 ? void 0 : onSelect();
    };
    const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
    return (jsxRuntime.jsx(core.Menu.Dropdown, { children: (_d = (header && column && columnDef
            ? (_c = (_b = columnDef.renderColumnFilterModeMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, {
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })) !== null && _c !== void 0 ? _c : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
                column: column,
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            })
            : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
                internalFilterOptions,
                onSelectFilterMode: handleSelectFilterMode,
                table,
            }))) !== null && _d !== void 0 ? _d : internalFilterOptions.map(({ option, label, divider, symbol }, index) => (jsxRuntime.jsxs(react.Fragment, { children: [jsxRuntime.jsxs(core.Menu.Item, { onClick: () => handleSelectFilterMode(option), color: option === filterOption ? 'blue' : undefined, sx: {
                        '& > .mantine-Menu-itemLabel': {
                            display: 'flex',
                            flexWrap: 'nowrap',
                            gap: '1ch',
                        },
                    }, value: option, children: [jsxRuntime.jsx(core.Flex, { sx: {
                                fontSize: '20px',
                                transform: 'translateY(-2px)',
                                width: '2ch',
                            }, children: symbol }), jsxRuntime.jsx(core.Flex, { align: "center", children: label })] }), divider && jsxRuntime.jsx(core.Menu.Divider, {})] }, index))) }));
};

const MRT_GlobalFilterTextInput = ({ table, }) => {
    const { getState, setGlobalFilter, options: { enableGlobalFilterModes, icons: { IconSearch, IconX }, localization, manualFiltering, mantineSearchTextInputProps, }, refs: { searchInputRef }, } = table;
    const { globalFilter, showGlobalFilter } = getState();
    const textFieldProps = mantineSearchTextInputProps instanceof Function
        ? mantineSearchTextInputProps({ table })
        : mantineSearchTextInputProps;
    const isMounted = react.useRef(false);
    const [searchValue, setSearchValue] = react.useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : '');
    const [debouncedSearchValue] = hooks.useDebouncedValue(searchValue, manualFiltering ? 500 : 250);
    react.useEffect(() => {
        setGlobalFilter(debouncedSearchValue || undefined);
    }, [debouncedSearchValue]);
    const handleClear = () => {
        setSearchValue('');
        setGlobalFilter(undefined);
    };
    react.useEffect(() => {
        if (isMounted.current) {
            if (globalFilter === undefined) {
                handleClear();
            }
            else {
                setSearchValue(globalFilter);
            }
        }
        isMounted.current = true;
    }, [globalFilter]);
    return (jsxRuntime.jsxs(core.Collapse, { in: showGlobalFilter, sx: {
            '& > div': {
                display: 'flex',
                alignItems: 'center',
                gap: '16px',
                flexWrap: 'nowrap',
            },
        }, children: [enableGlobalFilterModes && (jsxRuntime.jsxs(core.Menu, { withinPortal: true, children: [jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.changeSearchMode, size: "sm", children: jsxRuntime.jsx(IconSearch, {}) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { table: table, onSelect: handleClear })] })), jsxRuntime.jsx(core.TextInput, Object.assign({ placeholder: localization.search, onChange: (event) => setSearchValue(event.target.value), value: searchValue !== null && searchValue !== void 0 ? searchValue : '', variant: "filled", icon: !enableGlobalFilterModes && jsxRuntime.jsx(IconSearch, {}), rightSection: searchValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "sm", children: jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.clearSearch, children: jsxRuntime.jsx(IconX, {}) }) })) : null }, textFieldProps, { ref: (node) => {
                    if (node) {
                        searchInputRef.current = node;
                        if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.ref) {
                            // @ts-ignore
                            textFieldProps.ref = node;
                        }
                    }
                }, sx: (theme) => (Object.assign({ minWidth: '250px' }, ((textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx) instanceof Function
                    ? textFieldProps.sx(theme)
                    : textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx))) }))] }));
};

const MRT_ProgressBar = ({ isTopToolbar, table, }) => {
    const { options: { mantineProgressProps }, getState, } = table;
    const { isSaving, showProgressBars } = getState();
    const linearProgressProps = mantineProgressProps instanceof Function
        ? mantineProgressProps({ isTopToolbar, table })
        : mantineProgressProps;
    return (jsxRuntime.jsx(core.Collapse, { in: isSaving || showProgressBars, sx: {
            bottom: isTopToolbar ? 0 : undefined,
            position: 'absolute',
            top: !isTopToolbar ? 0 : undefined,
            width: '100%',
        }, children: jsxRuntime.jsx(core.Progress, Object.assign({ animate: true, "aria-busy": "true", "aria-label": "Loading", radius: 0, value: 100 }, linearProgressProps)) }));
};

const commonActionButtonStyles = {
    userSelect: 'none',
    '&:disabled': {
        backgroundColor: 'transparent',
        border: 'none',
    },
};
const MRT_TablePagination = ({ table, position = 'bottom', }) => {
    var _a;
    const { getPrePaginationRowModel, getState, setPageIndex, setPageSize, options: { enableToolbarInternalActions, icons: { IconChevronLeftPipe, IconChevronRightPipe, IconChevronLeft, IconChevronRight, }, localization, mantinePaginationProps, paginationDisplayMode, rowCount, }, } = table;
    const { pagination: { pageSize = 10, pageIndex = 0 }, showGlobalFilter, } = getState();
    const paginationProps = mantinePaginationProps instanceof Function
        ? mantinePaginationProps({ table })
        : mantinePaginationProps;
    const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
    const numberOfPages = Math.ceil(totalRowCount / pageSize);
    const showFirstLastPageButtons = numberOfPages > 2 && (paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.withEdges) !== false;
    const firstRowIndex = pageIndex * pageSize;
    const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);
    return (jsxRuntime.jsxs(core.Flex, { align: "center", justify: "space-between", gap: "lg", py: "xs", px: "sm", mt: position === 'top' && enableToolbarInternalActions && !showGlobalFilter
            ? '3rem'
            : undefined, p: "relative", sx: { zIndex: 2 }, children: [(paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.showRowsPerPage) !== false && (jsxRuntime.jsx(core.Select, { data: (_a = paginationProps === null || paginationProps === void 0 ? void 0 : paginationProps.rowsPerPageOptions) !== null && _a !== void 0 ? _a : [
                    '5',
                    '10',
                    '15',
                    '20',
                    '25',
                    '30',
                    '50',
                    '100',
                ], label: localization.rowsPerPage, onChange: (value) => setPageSize(+value), value: pageSize.toString(), sx: {
                    '@media (min-width: 720px)': {
                        display: 'flex',
                        alignItems: 'center',
                        gap: '8px',
                    },
                    '& .mantine-Select-input': {
                        width: '80px',
                    },
                }, withinPortal: true })), paginationDisplayMode === 'pages' ? (jsxRuntime.jsx(core.Pagination, Object.assign({ onChange: (newPageIndex) => setPageIndex(newPageIndex - 1), total: numberOfPages, value: pageIndex + 1, withEdges: showFirstLastPageButtons, nextIcon: IconChevronRight, previousIcon: IconChevronLeft, firstIcon: IconChevronLeftPipe, lastIcon: IconChevronRightPipe }, paginationProps))) : paginationDisplayMode === 'default' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Text, { children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), jsxRuntime.jsxs(core.Flex, { gap: "xs", children: [showFirstLastPageButtons && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToFirstPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(0), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronLeftPipe, {}) })), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToPreviousPage, disabled: pageIndex <= 0, onClick: () => setPageIndex(pageIndex - 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronLeft, {}) }), jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToNextPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(pageIndex + 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronRight, {}) }), showFirstLastPageButtons && (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.goToLastPage, disabled: lastRowIndex >= totalRowCount, onClick: () => setPageIndex(numberOfPages - 1), sx: commonActionButtonStyles, children: jsxRuntime.jsx(IconChevronRightPipe, {}) }))] })] })) : null] }));
};

const MRT_FilterCheckbox = ({ column, table, }) => {
    var _a, _b, _c;
    const { getState, options: { localization, mantineFilterCheckboxProps }, } = table;
    const { density } = getState();
    const { columnDef } = column;
    const mTableHeadCellFilterCheckboxProps = mantineFilterCheckboxProps instanceof Function
        ? mantineFilterCheckboxProps({
            column,
            table,
        })
        : mantineFilterCheckboxProps;
    const mcTableHeadCellFilterCheckboxProps = columnDef.mantineFilterCheckboxProps instanceof Function
        ? columnDef.mantineFilterCheckboxProps({
            column,
            table,
        })
        : columnDef.mantineFilterCheckboxProps;
    const checkboxProps = Object.assign(Object.assign({}, mTableHeadCellFilterCheckboxProps), mcTableHeadCellFilterCheckboxProps);
    const filterLabel = (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', columnDef.header);
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : filterLabel, children: jsxRuntime.jsx(core.Checkbox, Object.assign({ checked: column.getFilterValue() === 'true', indeterminate: column.getFilterValue() === undefined, color: column.getFilterValue() === undefined ? 'default' : 'primary', size: density === 'xs' ? 'sm' : 'md', label: (_c = checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel }, checkboxProps, { onClick: (e) => {
                var _a;
                e.stopPropagation();
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, onChange: (e) => {
                var _a;
                column.setFilterValue(column.getFilterValue() === undefined
                    ? 'true'
                    : column.getFilterValue() === 'true'
                        ? 'false'
                        : undefined);
                (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a === void 0 ? void 0 : _a.call(checkboxProps, e);
            }, sx: (theme) => (Object.assign({ fontWeight: 'normal', marginTop: '8px' }, ((checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx) instanceof Function
                ? checkboxProps.sx(theme)
                : checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx))), title: undefined })) }));
};

const MRT_FilterTextInput = ({ header, rangeFilterIndex, table, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const { options: { columnFilterDisplayMode, columnFilterModeOptions, icons: { IconX }, localization, mantineFilterAutocompleteProps, mantineFilterDateInputProps, mantineFilterMultiSelectProps, mantineFilterSelectProps, mantineFilterTextInputProps, manualFiltering, }, refs: { filterInputRefs }, setColumnFilterFns, } = table;
    const { column } = header;
    const { columnDef } = column;
    const mFilterTextInputProps = mantineFilterTextInputProps instanceof Function
        ? mantineFilterTextInputProps({
            column,
            table,
            rangeFilterIndex,
        })
        : mantineFilterTextInputProps;
    const mcFilterTextInputProps = columnDef.mantineFilterTextInputProps instanceof Function
        ? columnDef.mantineFilterTextInputProps({
            column,
            table,
            rangeFilterIndex,
        })
        : columnDef.mantineFilterTextInputProps;
    const textInputProps = Object.assign(Object.assign({}, mFilterTextInputProps), mcFilterTextInputProps);
    const mSelectProps = mantineFilterSelectProps instanceof Function
        ? mantineFilterSelectProps({ column, table, rangeFilterIndex })
        : mantineFilterSelectProps;
    const mcSelectProps = columnDef.mantineFilterSelectProps instanceof Function
        ? columnDef.mantineFilterSelectProps({ column, table, rangeFilterIndex })
        : columnDef.mantineFilterSelectProps;
    const selectProps = Object.assign(Object.assign({}, mSelectProps), mcSelectProps);
    const mMultiSelectProps = mantineFilterMultiSelectProps instanceof Function
        ? mantineFilterMultiSelectProps({ column, table, rangeFilterIndex })
        : mantineFilterMultiSelectProps;
    const mcMultiSelectProps = columnDef.mantineFilterMultiSelectProps instanceof Function
        ? columnDef.mantineFilterMultiSelectProps({
            column,
            table,
            rangeFilterIndex,
        })
        : columnDef.mantineFilterMultiSelectProps;
    const multiSelectProps = Object.assign(Object.assign({}, mMultiSelectProps), mcMultiSelectProps);
    const mDateInputProps = mantineFilterDateInputProps instanceof Function
        ? mantineFilterDateInputProps({ column, table, rangeFilterIndex })
        : mantineFilterDateInputProps;
    const mcDateInputProps = columnDef.mantineFilterDateInputProps instanceof Function
        ? columnDef.mantineFilterDateInputProps({
            column,
            table,
            rangeFilterIndex,
        })
        : columnDef.mantineFilterDateInputProps;
    const dateInputProps = Object.assign(Object.assign({}, mDateInputProps), mcDateInputProps);
    const mAutoCompleteProps = mantineFilterAutocompleteProps instanceof Function
        ? mantineFilterAutocompleteProps({ column, table, rangeFilterIndex })
        : mantineFilterAutocompleteProps;
    const mcAutoCompleteProps = columnDef.mantineFilterAutocompleteProps instanceof Function
        ? columnDef.mantineFilterAutocompleteProps({
            column,
            table,
            rangeFilterIndex,
        })
        : columnDef.mantineFilterAutocompleteProps;
    const autoCompleteProps = Object.assign(Object.assign({}, mAutoCompleteProps), mcAutoCompleteProps);
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        columnDef.filterVariant === 'date-range' ||
        rangeFilterIndex !== undefined;
    const isSelectFilter = columnDef.filterVariant === 'select';
    const isMultiSelectFilter = columnDef.filterVariant === 'multi-select';
    const isDateFilter = columnDef.filterVariant === 'date' ||
        columnDef.filterVariant === 'date-range';
    const isAutoCompleteFilter = columnDef.filterVariant === 'autocomplete';
    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    const currentFilterOption = columnDef._filterFn;
    const filterChipLabel = ['empty', 'notEmpty'].includes(currentFilterOption)
        ? //@ts-ignore
            localization[`filter${((_c = (_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b === void 0 ? void 0 : _b.call(currentFilterOption, 0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +
                (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
        : '';
    const filterPlaceholder = !isRangeFilter
        ? (_d = textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.placeholder) !== null && _d !== void 0 ? _d : (_e = localization.filterByColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header))
        : rangeFilterIndex === 0
            ? localization.min
            : rangeFilterIndex === 1
                ? localization.max
                : '';
    const facetedUniqueValues = column.getFacetedUniqueValues();
    const filterSelectOptions = react.useMemo(() => {
        var _a, _b, _c;
        return ((_c = (_b = (_a = autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data) !== null && _a !== void 0 ? _a : selectProps === null || selectProps === void 0 ? void 0 : selectProps.data) !== null && _b !== void 0 ? _b : multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data) !== null && _c !== void 0 ? _c : ((isAutoCompleteFilter || isSelectFilter || isMultiSelectFilter) &&
            facetedUniqueValues
            ? Array.from(facetedUniqueValues.keys()).sort((a, b) => a.localeCompare(b))
            : []))
            //@ts-ignore
            .filter((o) => o !== undefined && o !== null);
    }, [
        autoCompleteProps === null || autoCompleteProps === void 0 ? void 0 : autoCompleteProps.data,
        facetedUniqueValues,
        isAutoCompleteFilter,
        isMultiSelectFilter,
        isSelectFilter,
        multiSelectProps === null || multiSelectProps === void 0 ? void 0 : multiSelectProps.data,
        selectProps === null || selectProps === void 0 ? void 0 : selectProps.data,
    ]);
    const isMounted = react.useRef(false);
    const [filterValue, setFilterValue] = react.useState(() => {
        var _a, _b;
        return isMultiSelectFilter
            ? column.getFilterValue() || []
            : isRangeFilter
                ? ((_a = column.getFilterValue()) === null || _a === void 0 ? void 0 : _a[rangeFilterIndex]) || ''
                : (_b = column.getFilterValue()) !== null && _b !== void 0 ? _b : '';
    });
    const [debouncedFilterValue] = hooks.useDebouncedValue(filterValue, manualFiltering ? 400 : 200);
    //send debounced filterValue to table instance
    react.useEffect(() => {
        if (!isMounted.current)
            return;
        if (isRangeFilter) {
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] =
                    debouncedFilterValue;
                return newFilterValues;
            });
        }
        else {
            column.setFilterValue(debouncedFilterValue !== null && debouncedFilterValue !== void 0 ? debouncedFilterValue : undefined);
        }
    }, [debouncedFilterValue]);
    //receive table filter value and set it to local state
    react.useEffect(() => {
        if (!isMounted.current) {
            isMounted.current = true;
            return;
        }
        const tableFilterValue = column.getFilterValue();
        if (tableFilterValue === undefined) {
            handleClear();
        }
        else if (isRangeFilter && rangeFilterIndex !== undefined) {
            setFilterValue((tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : ['', ''])[rangeFilterIndex]);
        }
        else {
            setFilterValue(tableFilterValue !== null && tableFilterValue !== void 0 ? tableFilterValue : '');
        }
    }, [column.getFilterValue()]);
    const handleClear = () => {
        if (isMultiSelectFilter) {
            setFilterValue([]);
            column.setFilterValue([]);
        }
        else if (isRangeFilter) {
            setFilterValue('');
            column.setFilterValue((old) => {
                const newFilterValues = Array.isArray(old) ? old : ['', ''];
                newFilterValues[rangeFilterIndex] = undefined;
                return newFilterValues;
            });
        }
        else {
            setFilterValue('');
            column.setFilterValue(undefined);
        }
    };
    if (columnDef.Filter) {
        return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: (_f = columnDef.Filter) === null || _f === void 0 ? void 0 : _f.call(columnDef, { column, header, rangeFilterIndex, table }) }));
    }
    const handleClearEmptyFilterChip = () => {
        setFilterValue('');
        column.setFilterValue(undefined);
        setColumnFilterFns((prev) => {
            var _a;
            return (Object.assign(Object.assign({}, prev), { [header.id]: (_a = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a !== void 0 ? _a : 'fuzzy' }));
        });
    };
    const commonProps = {
        disabled: !!filterChipLabel,
        placeholder: filterPlaceholder,
        'aria-label': filterPlaceholder,
        title: filterPlaceholder,
        onClick: (event) => event.stopPropagation(),
        onChange: setFilterValue,
        value: filterValue,
        variant: 'unstyled',
        sx: (theme) => (Object.assign({ borderBottom: `2px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 7 : 3]}`, minWidth: isDateFilter
                ? '125px'
                : isRangeFilter
                    ? '80px'
                    : !filterChipLabel
                        ? '100px'
                        : 'auto', width: '100%', '& .mantine-TextInput-input': {
                overflow: 'hidden',
                textOverflow: 'ellipsis',
            }, '& .mantine-DateInput-input': {
                height: '2.1rem',
            } }, core.packSx(isMultiSelectFilter
            ? multiSelectProps.sx
            : isSelectFilter
                ? selectProps.sx
                : isDateFilter
                    ? dateInputProps.sx
                    : textInputProps === null || textInputProps === void 0 ? void 0 : textInputProps.sx))),
    };
    const ClearButton = filterValue ? (jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.clearFilter, onClick: handleClear, size: "sm", title: (_g = localization.clearFilter) !== null && _g !== void 0 ? _g : '', children: jsxRuntime.jsx(IconX, {}) })) : null;
    return filterChipLabel ? (jsxRuntime.jsx(core.Box, { sx: commonProps.sx, children: jsxRuntime.jsx(core.Badge, { size: "lg", onClick: handleClearEmptyFilterChip, sx: { margin: '5px' }, rightSection: ClearButton, children: filterChipLabel }) })) : isMultiSelectFilter ? (jsxRuntime.jsx(core.MultiSelect, Object.assign({}, commonProps, { clearable: true, searchable: true, withinPortal: true }, multiSelectProps, { data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (multiSelectProps.ref) {
                    multiSelectProps.ref.current = node;
                }
            }
        }, sx: commonProps.sx }))) : isSelectFilter ? (jsxRuntime.jsx(core.Select, Object.assign({}, commonProps, { clearable: true, searchable: true, withinPortal: true }, selectProps, { data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (selectProps.ref) {
                    selectProps.ref.current = node;
                }
            }
        }, sx: commonProps.sx }))) : isDateFilter ? (jsxRuntime.jsx(dates.DateInput, Object.assign({}, commonProps, { allowDeselect: true, clearable: true, popoverProps: { withinPortal: columnFilterDisplayMode !== 'popover' } }, dateInputProps, { ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (dateInputProps.ref) {
                    dateInputProps.ref.current = node;
                }
            }
        }, sx: commonProps.sx }))) : isAutoCompleteFilter ? (jsxRuntime.jsx(core.Autocomplete, Object.assign({}, commonProps, { rightSection: ((_h = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _h === void 0 ? void 0 : _h.length) ? ClearButton : undefined, onChange: (value) => setFilterValue(value), withinPortal: true }, autoCompleteProps, { data: filterSelectOptions, ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (autoCompleteProps.ref) {
                    autoCompleteProps.ref.current = node;
                }
            }
        }, sx: commonProps.sx }))) : (jsxRuntime.jsx(core.TextInput, Object.assign({}, commonProps, { rightSection: ((_j = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j === void 0 ? void 0 : _j.length) ? ClearButton : undefined, onChange: (e) => setFilterValue(e.target.value) }, textInputProps, { ref: (node) => {
            if (node) {
                filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] =
                    node;
                if (textInputProps.ref) {
                    textInputProps.ref.current = node;
                }
            }
        }, sx: commonProps.sx })));
};

const MRT_FilterRangeFields = ({ header, table, }) => {
    return (jsxRuntime.jsxs(core.Box, { sx: { display: 'grid', gridTemplateColumns: '6fr 6fr', gap: '16px' }, children: [jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 0, table: table }), jsxRuntime.jsx(MRT_FilterTextInput, { header: header, rangeFilterIndex: 1, table: table })] }));
};

const MRT_ToolbarAlertBanner = ({ stackAlertBanner, table, }) => {
    var _a, _b, _c;
    const { getPrePaginationRowModel, getSelectedRowModel, getState, options: { enableRowSelection, enableSelectAll, icons: { IconX }, localization, mantineToolbarAlertBannerBadgeProps, mantineToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount, }, } = table;
    const { grouping, showAlertBanner, density } = getState();
    const alertProps = mantineToolbarAlertBannerProps instanceof Function
        ? mantineToolbarAlertBannerProps({ table })
        : mantineToolbarAlertBannerProps;
    const badgeProps = mantineToolbarAlertBannerBadgeProps instanceof Function
        ? mantineToolbarAlertBannerBadgeProps({ table })
        : mantineToolbarAlertBannerBadgeProps;
    const selectedAlert = getSelectedRowModel().rows.length > 0
        ? (_b = (_a = localization.selectedCountOfRowCountRowsSelected) === null || _a === void 0 ? void 0 : _a.replace('{selectedCount}', getSelectedRowModel().rows.length.toString())) === null || _b === void 0 ? void 0 : _b.replace('{rowCount}', (rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length).toString())
        : null;
    const groupedAlert = grouping.length > 0 ? (jsxRuntime.jsxs(core.Flex, { children: [localization.groupedBy, ' ', grouping.map((columnId, index) => (jsxRuntime.jsxs(react.Fragment, { children: [index > 0 ? localization.thenBy : '', jsxRuntime.jsxs(core.Badge, Object.assign({ rightSection: jsxRuntime.jsx(core.ActionIcon, { onClick: () => table.getColumn(columnId).toggleGrouping(), size: "xs", children: jsxRuntime.jsx(IconX, {}) }), sx: { marginLeft: '1ch' }, variant: "filled" }, badgeProps, { children: [table.getColumn(columnId).columnDef.header, ' '] }))] }, `${index}-${columnId}`)))] })) : null;
    return (jsxRuntime.jsx(core.Collapse, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, transitionDuration: stackAlertBanner ? 200 : 0, children: jsxRuntime.jsx(core.Alert, Object.assign({ color: "blue", icon: false }, alertProps, { sx: (theme) => (Object.assign({ borderRadius: 0, fontSize: '16px', left: 0, position: 'relative', marginBottom: stackAlertBanner
                    ? 0
                    : positionToolbarAlertBanner === 'bottom'
                        ? '-16px'
                        : undefined, padding: '8px', right: 0, top: 0, width: '100%', zIndex: 2 }, ((alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx) instanceof Function
                ? alertProps.sx(theme)
                : alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx))), children: (_c = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({
                groupedAlert,
                selectedAlert,
                table,
            })) !== null && _c !== void 0 ? _c : (jsxRuntime.jsxs(core.Flex, { sx: {
                    gap: '12px',
                    padding: positionToolbarAlertBanner === 'head-overlay'
                        ? density === 'xl'
                            ? '16px'
                            : density === 'md'
                                ? '8px'
                                : '2px'
                        : '8px 16px',
                }, children: [enableRowSelection &&
                        enableSelectAll &&
                        positionToolbarAlertBanner === 'head-overlay' && (jsxRuntime.jsx(MRT_SelectCheckbox, { selectAll: true, table: table })), jsxRuntime.jsxs(core.Stack, { children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && (jsxRuntime.jsx("br", {})), selectedAlert, selectedAlert && groupedAlert && jsxRuntime.jsx("br", {}), groupedAlert] })] })) })) }));
};

const MRT_ToggleFullScreenButton = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { icons: { IconMinimize, IconMaximize }, localization, }, setIsFullScreen, } = table;
    const { isFullScreen } = getState();
    const [tooltipOpened, setTooltipOpened] = react.useState(false);
    const handleToggleFullScreen = () => {
        setTooltipOpened(false);
        setIsFullScreen(!isFullScreen);
    };
    return (jsxRuntime.jsx(core.Tooltip, { opened: tooltipOpened, withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.toggleFullScreen, onClick: handleToggleFullScreen, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "lg" }, rest, { title: undefined, children: isFullScreen ? jsxRuntime.jsx(IconMinimize, {}) : jsxRuntime.jsx(IconMaximize, {}) })) }));
};

const MRT_ColumnPinningButtons = ({ column, table, }) => {
    const { options: { icons: { IconPinned, IconPinnedOff }, localization, }, } = table;
    const handlePinColumn = (pinDirection) => {
        column.pin(pinDirection);
    };
    return (jsxRuntime.jsx(core.Flex, { sx: {
            minWidth: '70px',
            alignContent: 'center',
            justifyContent: 'center',
        }, children: column.getIsPinned() ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.unpin, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn(false), size: "md", children: jsxRuntime.jsx(IconPinnedOff, {}) }) })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToLeft, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn('left'), size: "md", children: jsxRuntime.jsx(IconPinned, { style: {
                                transform: 'rotate(90deg)',
                            } }) }) }), jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: localization.pinToRight, children: jsxRuntime.jsx(core.ActionIcon, { onClick: () => handlePinColumn('right'), size: "md", children: jsxRuntime.jsx(IconPinned, { style: {
                                transform: 'rotate(-90deg)',
                            } }) }) })] })) }));
};

const MRT_ShowHideColumnsMenuItems = ({ allColumns, hoveredColumn, setHoveredColumn, column, isSubMenu, table, }) => {
    var _a;
    const { getState, options: { enableColumnOrdering, enableHiding, enablePinning, localization, }, setColumnOrder, } = table;
    const { columnOrder } = getState();
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const switchChecked = (columnDefType !== 'group' && column.getIsVisible()) ||
        (columnDefType === 'group' &&
            column.getLeafColumns().some((col) => col.getIsVisible()));
    const handleToggleColumnHidden = (column) => {
        var _a, _b;
        if (columnDefType === 'group') {
            (_b = (_a = column === null || column === void 0 ? void 0 : column.columns) === null || _a === void 0 ? void 0 : _a.forEach) === null || _b === void 0 ? void 0 : _b.call(_a, (childColumn) => {
                childColumn.toggleVisibility(!switchChecked);
            });
        }
        else {
            column.toggleVisibility();
        }
    };
    const menuItemRef = react.useRef(null);
    const [isDragging, setIsDragging] = react.useState(false);
    const handleDragStart = (e) => {
        setIsDragging(true);
        e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
    };
    const handleDragEnd = (_e) => {
        setIsDragging(false);
        setHoveredColumn(null);
        if (hoveredColumn) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
    };
    const handleDragEnter = (_e) => {
        if (!isDragging && columnDef.enableColumnOrdering !== false) {
            setHoveredColumn(column);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { component: "span", ref: menuItemRef, onDragEnter: handleDragEnter, sx: (theme) => ({
                    alignItems: 'center',
                    cursor: 'default',
                    justifyContent: 'flex-start',
                    opacity: isDragging ? 0.5 : 1,
                    outline: isDragging
                        ? `1px dashed ${theme.colors.gray[7]}`
                        : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id
                            ? `2px dashed ${getPrimaryColor(theme)}`
                            : 'none',
                    paddingLeft: `${(column.depth + 0.5) * 2}rem`,
                    paddingTop: '6px',
                    paddingBottom: '6px',
                }), children: jsxRuntime.jsxs(core.Box, { sx: {
                        display: 'flex',
                        flexWrap: 'nowrap',
                        gap: '8px',
                    }, children: [!isSubMenu &&
                            columnDefType !== 'group' &&
                            enableColumnOrdering &&
                            !allColumns.some((col) => col.columnDef.columnDefType === 'group') &&
                            (columnDef.enableColumnOrdering !== false ? (jsxRuntime.jsx(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table: table })) : (jsxRuntime.jsx(core.Box, { sx: { width: '22px' } }))), !isSubMenu &&
                            enablePinning &&
                            (column.getCanPin() ? (jsxRuntime.jsx(MRT_ColumnPinningButtons, { column: column, table: table })) : (jsxRuntime.jsx(core.Box, { sx: { width: '70px' } }))), enableHiding ? (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: localization.toggleVisibility, children: jsxRuntime.jsx(core.Switch, { checked: switchChecked, disabled: (isSubMenu && switchChecked) || !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column), sx: {
                                    cursor: 'pointer !important',
                                } }) })) : (jsxRuntime.jsx(core.Text, { sx: { alignSelf: 'center' }, children: columnDef.header }))] }) }), (_a = column.columns) === null || _a === void 0 ? void 0 : _a.map((c, i) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: c, hoveredColumn: hoveredColumn, isSubMenu: isSubMenu, setHoveredColumn: setHoveredColumn, table: table }, `${i}-${c.id}`)))] }));
};

const MRT_ShowHideColumnsMenu = ({ isSubMenu, table, }) => {
    const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, toggleAllColumnsVisible, options: { enableColumnOrdering, enableHiding, enablePinning, localization, }, } = table;
    const { columnOrder, columnPinning } = getState();
    const hideAllColumns = () => {
        getAllLeafColumns()
            .filter((col) => col.columnDef.enableHiding !== false)
            .forEach((col) => col.toggleVisibility(false));
    };
    const allColumns = react.useMemo(() => {
        const columns = getAllColumns();
        if (columnOrder.length > 0 &&
            !columns.some((col) => col.columnDef.columnDefType === 'group')) {
            return [
                ...getLeftLeafColumns(),
                ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
                ...getRightLeafColumns(),
            ].filter(Boolean);
        }
        return columns;
    }, [
        columnOrder,
        columnPinning,
        getAllColumns(),
        getCenterLeafColumns(),
        getLeftLeafColumns(),
        getRightLeafColumns(),
    ]);
    const [hoveredColumn, setHoveredColumn] = react.useState(null);
    return (jsxRuntime.jsxs(core.Menu.Dropdown, { sx: {
            maxHeight: 'calc(80vh - 100px)',
            overflowY: 'auto',
        }, children: [jsxRuntime.jsxs(core.Flex, { sx: {
                    justifyContent: isSubMenu ? 'center' : 'space-between',
                    padding: '8px',
                    gap: '8px',
                }, children: [!isSubMenu && enableHiding && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsVisible(), onClick: hideAllColumns, variant: "subtle", children: localization.hideAll })), !isSubMenu && enableColumnOrdering && (jsxRuntime.jsx(core.Button, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options)), variant: "subtle", children: localization.resetOrder })), !isSubMenu && enablePinning && (jsxRuntime.jsx(core.Button, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), variant: "subtle", children: localization.unpinAll })), enableHiding && (jsxRuntime.jsx(core.Button, { disabled: getIsAllColumnsVisible(), onClick: () => toggleAllColumnsVisible(true), variant: "subtle", children: localization.showAll }))] }), jsxRuntime.jsx(core.Divider, {}), allColumns.map((column, index) => (jsxRuntime.jsx(MRT_ShowHideColumnsMenuItems, { allColumns: allColumns, column: column, hoveredColumn: hoveredColumn, isSubMenu: isSubMenu, setHoveredColumn: setHoveredColumn, table: table }, `${index}-${column.id}`)))] }));
};

const MRT_ShowHideColumnsButton = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { options: { icons: { IconColumns }, localization, }, } = table;
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: false, withinPortal: true, children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.showHideColumns, size: "lg" }, rest, { title: undefined, children: jsxRuntime.jsx(IconColumns, {}) })) }) }), jsxRuntime.jsx(MRT_ShowHideColumnsMenu, { table: table })] }));
};

const sizes = ['xs', 'md', 'xl'];
const MRT_ToggleDensePaddingButton = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization, }, setDensity, } = table;
    const { density } = getState();
    const handleToggleDensePadding = () => {
        var _a;
        setDensity((_a = sizes[(sizes.indexOf(density) - 1) % sizes.length]) !== null && _a !== void 0 ? _a : 'xl');
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.toggleDensity, onClick: handleToggleDensePadding, size: "lg" }, rest, { title: undefined, children: density === 'xs' ? (jsxRuntime.jsx(IconBaselineDensitySmall, {})) : density === 'md' ? (jsxRuntime.jsx(IconBaselineDensityMedium, {})) : (jsxRuntime.jsx(IconBaselineDensityLarge, {})) })) }));
};

const MRT_ToggleFiltersButton = (_a) => {
    var _b;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { icons: { IconFilter, IconFilterOff }, localization, }, setShowColumnFilters, } = table;
    const { showColumnFilters } = getState();
    const handleToggleShowFilters = () => {
        setShowColumnFilters(!showColumnFilters);
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleShowFilters, size: "lg" }, rest, { title: undefined, children: showColumnFilters ? jsxRuntime.jsx(IconFilterOff, {}) : jsxRuntime.jsx(IconFilter, {}) })) }));
};

const MRT_ToggleGlobalFilterButton = (_a) => {
    var _b, _c;
    var { table } = _a, rest = __rest(_a, ["table"]);
    const { getState, options: { icons: { IconSearch, IconSearchOff }, localization, }, refs: { searchInputRef }, setShowGlobalFilter, } = table;
    const { globalFilter, showGlobalFilter } = getState();
    const handleToggleSearch = () => {
        setShowGlobalFilter(!showGlobalFilter);
        setTimeout(() => { var _a; return (_a = searchInputRef.current) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch, children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch, size: "lg" }, rest, { title: undefined, children: showGlobalFilter ? jsxRuntime.jsx(IconSearchOff, {}) : jsxRuntime.jsx(IconSearch, {}) })) }));
};

const MRT_ToolbarInternalButtons = ({ table, }) => {
    var _a;
    const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, enablePinning, initialState, renderToolbarInternalActions, }, } = table;
    return (jsxRuntime.jsx(core.Flex, { sx: {
            alignItems: 'center',
            gap: '2px',
            zIndex: 3,
        }, children: (_a = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({
            table,
        })) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableFilters &&
                    enableGlobalFilter &&
                    !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (jsxRuntime.jsx(MRT_ToggleGlobalFilterButton, { table: table })), enableFilters &&
                    enableColumnFilters &&
                    columnFilterDisplayMode !== 'popover' && (jsxRuntime.jsx(MRT_ToggleFiltersButton, { table: table })), (enableHiding || enableColumnOrdering || enablePinning) && (jsxRuntime.jsx(MRT_ShowHideColumnsButton, { table: table })), enableDensityToggle && (jsxRuntime.jsx(MRT_ToggleDensePaddingButton, { table: table })), enableFullScreenToggle && (jsxRuntime.jsx(MRT_ToggleFullScreenButton, { table: table }))] })) }));
};

const MRT_ToolbarDropZone = ({ table, }) => {
    const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone, } = table;
    const { draggingColumn, hoveredColumn, grouping, showToolbarDropZone } = getState();
    const handleDragEnter = (_event) => {
        setHoveredColumn({ id: 'drop-zone' });
    };
    react.useEffect(() => {
        var _a;
        if (((_a = table.options.state) === null || _a === void 0 ? void 0 : _a.showToolbarDropZone) !== undefined) {
            setShowToolbarDropZone(!!enableGrouping &&
                !!draggingColumn &&
                draggingColumn.columnDef.enableGrouping !== false &&
                !grouping.includes(draggingColumn.id));
        }
    }, [enableGrouping, draggingColumn, grouping]);
    return (jsxRuntime.jsx(core.Transition, { mounted: showToolbarDropZone, transition: "fade", children: (styles) => {
            var _a, _b;
            return (jsxRuntime.jsx(core.Flex, { className: "mantine-ToolbarDropZone", sx: (theme) => ({
                    alignItems: 'center',
                    backgroundColor: theme.fn.rgba(getPrimaryColor(theme), (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone' ? 0.2 : 0.1),
                    border: `dashed ${getPrimaryColor(theme)} 2px`,
                    justifyContent: 'center',
                    height: 'calc(100%)',
                    position: 'absolute',
                    width: 'calc(100%)',
                    zIndex: 2,
                }), onDragEnter: handleDragEnter, style: styles, children: jsxRuntime.jsx(core.Text, { children: localization.dropToGroupBy.replace('{column}', (_b = (_a = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _a === void 0 ? void 0 : _a.header) !== null && _b !== void 0 ? _b : '') }) }));
        } }));
};

const commonToolbarStyles = ({ theme }) => ({
    alignItems: 'flex-start',
    backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white,
    backgroundImage: 'none',
    display: 'grid',
    flexWrap: 'wrap-reverse',
    minHeight: '3.5rem',
    overflow: 'visible',
    padding: '0',
    transition: 'all 100ms ease-in-out',
    zIndex: 3,
});
const MRT_TopToolbar = ({ table, }) => {
    var _a;
    const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, mantineTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions, }, refs: { topToolbarRef }, } = table;
    const { isFullScreen, showGlobalFilter } = getState();
    const isMobile = hooks.useMediaQuery('(max-width: 720px)');
    const toolbarProps = mantineTopToolbarProps instanceof Function
        ? mantineTopToolbarProps({ table })
        : mantineTopToolbarProps;
    const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { ref: (node) => {
            if (node) {
                topToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, sx: (theme) => (Object.assign(Object.assign({ position: isFullScreen ? 'sticky' : 'relative', top: isFullScreen ? '0' : undefined }, commonToolbarStyles({ theme })), ((toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function
            ? toolbarProps.sx(theme)
            : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx))), children: [positionToolbarAlertBanner === 'top' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'top'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Flex, { sx: {
                    alignItems: 'flex-start',
                    boxSizing: 'border-box',
                    justifyContent: 'space-between',
                    padding: '8px',
                    position: stackAlertBanner ? 'relative' : 'absolute',
                    right: 0,
                    top: 0,
                    width: '100%',
                }, children: [enableGlobalFilter && positionGlobalFilter === 'left' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : jsxRuntime.jsx("span", {}), enableToolbarInternalActions ? (jsxRuntime.jsxs(core.Flex, { sx: {
                            flexWrap: 'wrap-reverse',
                            justifyContent: 'flex-end',
                        }, children: [enableGlobalFilter && positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })), jsxRuntime.jsx(MRT_ToolbarInternalButtons, { table: table })] })) : (enableGlobalFilter &&
                        positionGlobalFilter === 'right' && (jsxRuntime.jsx(MRT_GlobalFilterTextInput, { table: table })))] }), enablePagination &&
                ['top', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(core.Flex, { justify: "end", children: jsxRuntime.jsx(MRT_TablePagination, { table: table, position: "top" }) })), jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: true, table: table })] })));
};

const MRT_BottomToolbar = ({ table, }) => {
    const { getState, options: { enablePagination, mantineBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions, }, refs: { bottomToolbarRef }, } = table;
    const { isFullScreen } = getState();
    const isMobile = hooks.useMediaQuery('(max-width: 720px)');
    const toolbarProps = mantineBottomToolbarProps instanceof Function
        ? mantineBottomToolbarProps({ table })
        : mantineBottomToolbarProps;
    const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, toolbarProps, { ref: (node) => {
            if (node) {
                bottomToolbarRef.current = node;
                if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
                    toolbarProps.ref.current = node;
                }
            }
        }, sx: (theme) => (Object.assign(Object.assign(Object.assign({}, commonToolbarStyles({ theme })), { bottom: isFullScreen ? '0' : undefined, boxShadow: `0 1px 2px -1px ${theme.fn.rgba(theme.black, 0.1)} inset`, left: 0, position: isFullScreen ? 'fixed' : 'relative', right: 0 }), ((toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx) instanceof Function
            ? toolbarProps.sx(theme)
            : toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx))), children: [jsxRuntime.jsx(MRT_ProgressBar, { isTopToolbar: false, table: table }), positionToolbarAlertBanner === 'bottom' && (jsxRuntime.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner: stackAlertBanner, table: table })), ['both', 'bottom'].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : '') && (jsxRuntime.jsx(MRT_ToolbarDropZone, { table: table })), jsxRuntime.jsxs(core.Box, { sx: {
                    alignItems: 'center',
                    boxSizing: 'border-box',
                    display: 'flex',
                    justifyContent: 'space-between',
                    padding: '8px',
                    width: '100%',
                }, children: [renderBottomToolbarCustomActions ? (renderBottomToolbarCustomActions({ table })) : (jsxRuntime.jsx("span", {})), jsxRuntime.jsx(core.Box, { sx: {
                            display: 'flex',
                            justifyContent: 'flex-end',
                            position: stackAlertBanner ? 'relative' : 'absolute',
                            right: 0,
                            top: 0,
                        }, children: enablePagination &&
                            ['bottom', 'both'].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : '') && (jsxRuntime.jsx(MRT_TablePagination, { table: table, position: "bottom" })) })] })] })));
};

const MRT_ColumnActionMenu = ({ header, table, }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const { getState, toggleAllColumnsVisible, setColumnOrder, options: { columnFilterDisplayMode, enableColumnFilters, enableColumnResizing, enableGrouping, enableHiding, enablePinning, enableSorting, enableSortingRemoval, icons: { IconArrowAutofitContent, IconBoxMultiple, IconClearAll, IconColumns, IconDotsVertical, IconEyeOff, IconFilter, IconFilterOff, IconPinned, IconPinnedOff, IconSortAscending, IconSortDescending, }, localization, mantineColumnActionsButtonProps, renderColumnActionsMenuItems, }, refs: { filterInputRefs }, setColumnSizingInfo, setShowColumnFilters, } = table;
    const { column } = header;
    const { columnDef } = column;
    const { columnSizing, columnVisibility } = getState();
    const mTableHeadCellColumnActionsButtonProps = mantineColumnActionsButtonProps instanceof Function
        ? mantineColumnActionsButtonProps({ column, table })
        : mantineColumnActionsButtonProps;
    const mcTableHeadCellColumnActionsButtonProps = columnDef.mantineColumnActionsButtonProps instanceof Function
        ? columnDef.mantineColumnActionsButtonProps({
            column,
            table,
        })
        : columnDef.mantineColumnActionsButtonProps;
    const actionIconProps = Object.assign(Object.assign({}, mTableHeadCellColumnActionsButtonProps), mcTableHeadCellColumnActionsButtonProps);
    const handleClearSort = () => {
        column.clearSorting();
    };
    const handleSortAsc = () => {
        column.toggleSorting(false);
    };
    const handleSortDesc = () => {
        column.toggleSorting(true);
    };
    const handleResetColumnSize = () => {
        setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
        column.resetSize();
    };
    const handleHideColumn = () => {
        column.toggleVisibility(false);
    };
    const handlePinColumn = (pinDirection) => {
        column.pin(pinDirection);
    };
    const handleGroupByColumn = () => {
        column.toggleGrouping();
        setColumnOrder((old) => ['mrt-row-expand', ...old]);
    };
    const handleClearFilter = () => {
        column.setFilterValue('');
    };
    const handleFilterByColumn = () => {
        setShowColumnFilters(true);
        setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100);
    };
    const handleShowAllColumns = () => {
        toggleAllColumnsVisible(true);
    };
    const internalColumnMenuItems = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSorting && column.getCanSort() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [enableSortingRemoval !== false && (jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsSorted(), icon: jsxRuntime.jsx(IconClearAll, {}), onClick: handleClearSort, children: localization.clearSort })), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsSorted() === 'asc', icon: jsxRuntime.jsx(IconSortAscending, {}), onClick: handleSortAsc, children: (_a = localization.sortByColumnAsc) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header)) }), jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconSortDescending, {}), disabled: column.getIsSorted() === 'desc', onClick: handleSortDesc, children: (_b = localization.sortByColumnDesc) === null || _b === void 0 ? void 0 : _b.replace('{column}', String(columnDef.header)) }), (enableColumnFilters || enableGrouping || enableHiding) && (jsxRuntime.jsx(core.Menu.Divider, {}, 3))] })), enableColumnFilters &&
                columnFilterDisplayMode !== 'popover' &&
                column.getCanFilter() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getFilterValue(), icon: jsxRuntime.jsx(IconFilterOff, {}), onClick: handleClearFilter, children: localization.clearFilter }), jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconFilter, {}), onClick: handleFilterByColumn, children: (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace('{column}', String(columnDef.header)) }), (enableGrouping || enableHiding) && jsxRuntime.jsx(core.Menu.Divider, {}, 2)] })), enableGrouping && column.getCanGroup() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { icon: jsxRuntime.jsx(IconBoxMultiple, {}), onClick: handleGroupByColumn, children: (_d = localization[column.getIsGrouped() ? 'ungroupByColumn' : 'groupByColumn']) === null || _d === void 0 ? void 0 : _d.replace('{column}', String(columnDef.header)) }), enablePinning && jsxRuntime.jsx(core.Menu.Divider, {})] })), enablePinning && column.getCanPin() && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'left' || !column.getCanPin(), icon: jsxRuntime.jsx(IconPinned, { style: { transform: 'rotate(90deg)' } }), onClick: () => handlePinColumn('left'), children: localization.pinToLeft }), jsxRuntime.jsx(core.Menu.Item, { disabled: column.getIsPinned() === 'right' || !column.getCanPin(), icon: jsxRuntime.jsx(IconPinned, { style: { transform: 'rotate(-90deg)' } }), onClick: () => handlePinColumn('right'), children: localization.pinToRight }), jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getIsPinned(), icon: jsxRuntime.jsx(IconPinnedOff, {}), onClick: () => handlePinColumn(false), children: localization.unpin }), enableHiding && jsxRuntime.jsx(core.Menu.Divider, {})] })), enableColumnResizing && column.getCanResize() && (jsxRuntime.jsx(core.Menu.Item, { disabled: !columnSizing[column.id], icon: jsxRuntime.jsx(IconArrowAutofitContent, {}), onClick: handleResetColumnSize, children: localization.resetColumnSize }, 0)), enableHiding && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(core.Menu.Item, { disabled: !column.getCanHide(), icon: jsxRuntime.jsx(IconEyeOff, {}), onClick: handleHideColumn, children: (_e = localization.hideColumn) === null || _e === void 0 ? void 0 : _e.replace('{column}', String(columnDef.header)) }, 0), jsxRuntime.jsx(core.Menu.Item, { disabled: !Object.values(columnVisibility).filter((visible) => !visible)
                            .length, icon: jsxRuntime.jsx(IconColumns, {}), onClick: handleShowAllColumns, children: (_f = localization.showAllColumns) === null || _f === void 0 ? void 0 : _f.replace('{column}', String(columnDef.header)) }, 1)] }))] }));
    return (jsxRuntime.jsxs(core.Menu, { closeOnItemClick: true, withinPortal: true, position: "bottom-start", children: [jsxRuntime.jsx(core.Tooltip, { withinPortal: true, openDelay: 1000, label: (_g = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.title) !== null && _g !== void 0 ? _g : localization.columnActions, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, Object.assign({ "aria-label": localization.columnActions, size: "sm" }, actionIconProps, { sx: (theme) => (Object.assign({ opacity: 0.5, transition: 'opacity 100ms', '&:hover': {
                                opacity: 1,
                            } }, ((actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx) instanceof Function
                            ? actionIconProps.sx(theme)
                            : actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.sx))), children: jsxRuntime.jsx(IconDotsVertical, {}) })) }) }), jsxRuntime.jsx(core.Menu.Dropdown, { children: (_k = (_j = (_h = columnDef.renderColumnActionsMenuItems) === null || _h === void 0 ? void 0 : _h.call(columnDef, {
                    column,
                    table,
                    internalColumnMenuItems,
                })) !== null && _j !== void 0 ? _j : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
                    column,
                    table,
                    internalColumnMenuItems,
                })) !== null && _k !== void 0 ? _k : internalColumnMenuItems })] }));
};

const MRT_FilterRangeSlider = ({ header, table, }) => {
    var _a;
    const { options: { mantineFilterRangeSliderProps }, refs: { filterInputRefs }, } = table;
    const { column } = header;
    const { columnDef } = column;
    const mFilterRangeSliderProps = mantineFilterRangeSliderProps instanceof Function
        ? mantineFilterRangeSliderProps({
            column,
            table,
        })
        : mantineFilterRangeSliderProps;
    const mcFilterRangeSliderProps = columnDef.mantineFilterRangeSliderProps instanceof Function
        ? columnDef.mantineFilterRangeSliderProps({
            column,
            table,
        })
        : columnDef.mantineFilterRangeSliderProps;
    const rangeSliderProps = Object.assign(Object.assign({}, mFilterRangeSliderProps), mcFilterRangeSliderProps);
    let [min, max] = rangeSliderProps.min !== undefined && rangeSliderProps.max !== undefined
        ? [rangeSliderProps.min, rangeSliderProps.max]
        : (_a = column.getFacetedMinMaxValues()) !== null && _a !== void 0 ? _a : [0, 1];
    //fix potential TanStack Table bugs where min or max is an array
    if (Array.isArray(min))
        min = min[0];
    if (Array.isArray(max))
        max = max[0];
    if (min === null)
        min = 0;
    if (max === null)
        max = 1;
    const [filterValues, setFilterValues] = react.useState([
        min,
        max,
    ]);
    const columnFilterValue = column.getFilterValue();
    const isMounted = react.useRef(false);
    react.useEffect(() => {
        if (isMounted.current) {
            if (columnFilterValue === undefined) {
                setFilterValues([min, max]);
            }
            else if (Array.isArray(columnFilterValue)) {
                setFilterValues(columnFilterValue);
            }
        }
        isMounted.current = true;
    }, [columnFilterValue, min, max]);
    return (jsxRuntime.jsx(core.RangeSlider, Object.assign({ min: min, max: max, onChange: (values) => {
            setFilterValues(values);
        }, onChangeEnd: (values) => {
            if (Array.isArray(values)) {
                if (values[0] <= min && values[1] >= max) {
                    //if the user has selected the entire range, remove the filter
                    column.setFilterValue(undefined);
                }
                else {
                    column.setFilterValue(values);
                }
            }
        }, value: filterValues }, rangeSliderProps, { ref: (node) => {
            if (node) {
                //@ts-ignore
                filterInputRefs.current[`${column.id}-0`] = node;
                // @ts-ignore
                if (rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.ref) {
                    //@ts-ignore
                    rangeSliderProps.ref = node;
                }
            }
        }, sx: (theme) => (Object.assign({ margin: 'auto', marginTop: '16px', marginBottom: '6px', width: 'calc(100% - 8px)' }, ((rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.sx) instanceof Function
            ? rangeSliderProps.sx(theme)
            : rangeSliderProps === null || rangeSliderProps === void 0 ? void 0 : rangeSliderProps.sx))) })));
};

const MRT_TableHeadCellFilterContainer = ({ header, table, }) => {
    var _a, _b, _c;
    const { getState, options: { columnFilterDisplayMode, enableColumnFilterModes, columnFilterModeOptions, icons: { IconFilterCog }, localization, }, refs: { filterInputRefs }, } = table;
    const { showColumnFilters } = getState();
    const { column } = header;
    const { columnDef } = column;
    const currentFilterOption = columnDef._filterFn;
    const allowedColumnFilterOptions = (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a !== void 0 ? _a : columnFilterModeOptions;
    const showChangeModeButton = enableColumnFilterModes &&
        columnDef.enableColumnFilterModes !== false &&
        (allowedColumnFilterOptions === undefined ||
            !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
    return (jsxRuntime.jsx(core.Collapse, { in: showColumnFilters || columnFilterDisplayMode === 'popover', children: jsxRuntime.jsxs(core.Flex, { direction: "column", children: [jsxRuntime.jsxs(core.Flex, { align: "flex-end", children: [columnDef.filterVariant === 'checkbox' ? (jsxRuntime.jsx(MRT_FilterCheckbox, { column: column, table: table })) : columnDef.filterVariant === 'range-slider' ? (jsxRuntime.jsx(MRT_FilterRangeSlider, { header: header, table: table })) : ['range', 'date-range'].includes((_b = columnDef.filterVariant) !== null && _b !== void 0 ? _b : '') ||
                            ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn) ? (jsxRuntime.jsx(MRT_FilterRangeFields, { header: header, table: table })) : (jsxRuntime.jsx(MRT_FilterTextInput, { header: header, table: table })), showChangeModeButton && (jsxRuntime.jsxs(core.Menu, { withinPortal: columnFilterDisplayMode !== 'popover', children: [jsxRuntime.jsx(core.Tooltip, { label: localization.changeFilterMode, position: "bottom-start", withinPortal: true, children: jsxRuntime.jsx(core.Menu.Target, { children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": localization.changeFilterMode, size: "md", sx: { transform: 'translateY(-2px)' }, children: jsxRuntime.jsx(IconFilterCog, {}) }) }) }), jsxRuntime.jsx(MRT_FilterOptionMenu, { header: header, table: table, onSelect: () => setTimeout(() => { var _a; return (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus(); }, 100) })] }))] }), showChangeModeButton ? (jsxRuntime.jsx(core.Text, { component: "label", color: "dimmed", sx: { whiteSpace: 'nowrap', marginTop: '4px', fontSize: '10px' }, children: localization.filterMode.replace('{filterType}', 
                    // @ts-ignore
                    localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) +
                        (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]) })) : null] }) }));
};

const MRT_TableHeadCellFilterLabel = ({ header, table, }) => {
    var _a, _b, _c, _d;
    const { options: { columnFilterDisplayMode, icons: { IconFilter }, localization, }, refs: { filterInputRefs }, setShowColumnFilters, } = table;
    const { column } = header;
    const { columnDef } = column;
    const theme = core.useMantineTheme();
    const filterValue = column.getFilterValue();
    const [popoverOpened, setPopoverOpened] = react.useState(false);
    const isFilterActive = (Array.isArray(filterValue) && filterValue.some(Boolean)) ||
        (!!filterValue && !Array.isArray(filterValue));
    const isRangeFilter = columnDef.filterVariant === 'range' ||
        ['between', 'betweenInclusive', 'inNumberRange'].includes(columnDef._filterFn);
    const currentFilterOption = columnDef._filterFn;
    const filterTooltip = columnFilterDisplayMode === 'popover' && !isFilterActive
        ? (_a = localization.filterByColumn) === null || _a === void 0 ? void 0 : _a.replace('{column}', String(columnDef.header))
        : localization.filteringByColumn
            .replace('{column}', String(columnDef.header))
            .replace('{filterType}', 
        // @ts-ignore
        localization[`filter${((_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _b === void 0 ? void 0 : _b.toUpperCase()) +
            (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`])
            .replace('{filterValue}', `"${Array.isArray(column.getFilterValue())
            ? column.getFilterValue().join(`" ${isRangeFilter ? localization.and : localization.or} "`)
            : column.getFilterValue()}"`)
            .replace('" "', '');
    return (jsxRuntime.jsxs(core.Popover, { onClose: () => setPopoverOpened(false), opened: popoverOpened, position: "top", keepMounted: columnDef.filterVariant === 'range-slider', shadow: "xl", width: 360, withinPortal: true, children: [jsxRuntime.jsx(core.Transition, { transition: "scale", mounted: columnFilterDisplayMode === 'popover' ||
                    (!!column.getFilterValue() && !isRangeFilter) ||
                    (isRangeFilter && // @ts-ignore
                        (!!((_c = column.getFilterValue()) === null || _c === void 0 ? void 0 : _c[0]) || !!((_d = column.getFilterValue()) === null || _d === void 0 ? void 0 : _d[1]))), children: (styles) => (jsxRuntime.jsx(core.Box, { component: "span", sx: { flex: '0 0' }, style: styles, children: jsxRuntime.jsx(core.Popover.Target, { children: jsxRuntime.jsx(core.Tooltip, { disabled: popoverOpened, label: filterTooltip, multiline: true, width: filterTooltip.length > 40 ? 300 : undefined, withinPortal: true, children: jsxRuntime.jsx(core.ActionIcon, { color: isFilterActive ? getPrimaryColor(theme) : undefined, onClick: (event) => {
                                    event.stopPropagation();
                                    if (columnFilterDisplayMode === 'popover') {
                                        setPopoverOpened((opened) => !opened);
                                    }
                                    else {
                                        setShowColumnFilters(true);
                                    }
                                    setTimeout(() => {
                                        var _a, _b;
                                        (_a = filterInputRefs.current[`${column.id}-0`]) === null || _a === void 0 ? void 0 : _a.focus();
                                        (_b = filterInputRefs.current[`${column.id}-0`]) === null || _b === void 0 ? void 0 : _b.select();
                                    }, 100);
                                }, size: "sm", sx: {
                                    opacity: isFilterActive ? 1 : 0.5,
                                    padding: '2px',
                                    '&:hover': {
                                        opacity: 1,
                                    },
                                }, children: jsxRuntime.jsx(IconFilter, {}) }) }) }) })) }), columnFilterDisplayMode === 'popover' && (jsxRuntime.jsx(core.Popover.Dropdown, { onClick: (event) => event.stopPropagation(), onKeyDown: (event) => event.key === 'Enter' && setPopoverOpened(false), children: jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }) }))] }));
};

const MRT_TableHeadCellGrabHandle = ({ column, table, tableHeadCellRef, }) => {
    const { getState, options: { enableColumnOrdering, mantineColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn, } = table;
    const { columnDef } = column;
    const { hoveredColumn, draggingColumn, columnOrder } = getState();
    const mActionIconProps = mantineColumnDragHandleProps instanceof Function
        ? mantineColumnDragHandleProps({ column, table })
        : mantineColumnDragHandleProps;
    const mcActionIconProps = columnDef.mantineColumnDragHandleProps instanceof Function
        ? columnDef.mantineColumnDragHandleProps({ column, table })
        : columnDef.mantineColumnDragHandleProps;
    const actionIconProps = Object.assign(Object.assign({}, mActionIconProps), mcActionIconProps);
    const handleDragStart = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragStart) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        setDraggingColumn(column);
        event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
    };
    const handleDragEnd = (event) => {
        var _a;
        (_a = actionIconProps === null || actionIconProps === void 0 ? void 0 : actionIconProps.onDragEnd) === null || _a === void 0 ? void 0 : _a.call(actionIconProps, event);
        if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            column.toggleGrouping();
        }
        else if (enableColumnOrdering &&
            hoveredColumn &&
            (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
            setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
        }
        setDraggingColumn(null);
        setHoveredColumn(null);
    };
    return (jsxRuntime.jsx(MRT_GrabHandleButton, { actionIconProps: actionIconProps, onDragStart: handleDragStart, onDragEnd: handleDragEnd, table: table }));
};

const MRT_TableHeadCellResizeHandle = ({ header, table, }) => {
    var _a;
    const { getState, options: { columnResizeMode }, setColumnSizingInfo, } = table;
    const { density } = getState();
    const { column } = header;
    return (jsxRuntime.jsx(core.Box, { onDoubleClick: () => {
            setColumnSizingInfo((old) => (Object.assign(Object.assign({}, old), { isResizingColumn: false })));
            column.resetSize();
        }, onMouseDown: header.getResizeHandler(), onTouchStart: header.getResizeHandler(), sx: (theme) => ({
            cursor: 'col-resize',
            marginRight: density === 'xl' ? '-24px' : density === 'md' ? '-20px' : '-14px',
            position: 'absolute',
            right: '4px',
            paddingLeft: '1px',
            paddingRight: '1px',
            '&:active > .mantine-Divider-vertical': {
                borderLeftColor: getPrimaryColor(theme),
            },
        }), style: {
            transform: column.getIsResizing() && columnResizeMode === 'onEnd'
                ? `translateX(${(_a = getState().columnSizingInfo.deltaOffset) !== null && _a !== void 0 ? _a : 0}px)`
                : undefined,
        }, children: jsxRuntime.jsx(core.Divider, { orientation: "vertical", size: "lg", sx: {
                borderRadius: '2px',
                borderWidth: '4px',
                height: '24px',
                touchAction: 'none',
                transition: column.getIsResizing()
                    ? undefined
                    : 'all 100ms ease-in-out',
                userSelect: 'none',
                zIndex: 4,
            } }) }));
};

const MRT_TableHeadCellSortLabel = ({ header, table, }) => {
    const { getState, options: { icons: { IconSortDescending, IconSortAscending, IconArrowsSort }, localization, }, } = table;
    const { column } = header;
    const { columnDef } = column;
    const { sorting } = getState();
    const theme = core.useMantineTheme();
    const sortTooltip = column.getIsSorted()
        ? column.getIsSorted() === 'desc'
            ? localization.sortedByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortedByColumnAsc.replace('{column}', columnDef.header)
        : column.getNextSortingOrder() === 'desc'
            ? localization.sortByColumnDesc.replace('{column}', columnDef.header)
            : localization.sortByColumnAsc.replace('{column}', columnDef.header);
    const showIndicator = sorting.length >= 2 && column.getSortIndex() !== -1;
    return (jsxRuntime.jsx(core.Tooltip, { withinPortal: true, label: sortTooltip, children: jsxRuntime.jsx(core.Indicator, { color: "transparent", disabled: !showIndicator, inline: true, label: column.getSortIndex() + 1, offset: 3, children: jsxRuntime.jsx(core.ActionIcon, { "aria-label": sortTooltip, color: column.getIsSorted() ? getPrimaryColor(theme) : undefined, size: "xs", sx: {
                    opacity: column.getIsSorted() ? 1 : 0.5,
                    transform: showIndicator
                        ? 'translate(-2px, 2px) scale(0.9)'
                        : undefined,
                    transition: 'opacity 100ms ease-in-out',
                    '&:hover': {
                        opacity: 1,
                    },
                }, children: column.getIsSorted() === 'desc' ? (jsxRuntime.jsx(IconSortDescending, {})) : column.getIsSorted() === 'asc' ? (jsxRuntime.jsx(IconSortAscending, {})) : (jsxRuntime.jsx(IconArrowsSort, {})) }) }) }));
};

const MRT_TableHeadCell = ({ header, table, }) => {
    var _a, _b, _c, _d;
    const theme = core.useMantineTheme();
    const { getState, options: { columnFilterDisplayMode, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableGrouping, enableMultiSort, layoutMode, mantineTableHeadCellProps, }, refs: { tableHeadCellRefs }, setHoveredColumn, } = table;
    const { density, draggingColumn, grouping, hoveredColumn } = getState();
    const { column } = header;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const mTableHeadCellProps = mantineTableHeadCellProps instanceof Function
        ? mantineTableHeadCellProps({ column, table })
        : mantineTableHeadCellProps;
    const mcTableHeadCellProps = columnDef.mantineTableHeadCellProps instanceof Function
        ? columnDef.mantineTableHeadCellProps({ column, table })
        : columnDef.mantineTableHeadCellProps;
    const tableCellProps = Object.assign(Object.assign({}, mTableHeadCellProps), mcTableHeadCellProps);
    const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) &&
        columnDef.enableColumnActions !== false;
    const showDragHandle = enableColumnDragging !== false &&
        columnDef.enableColumnDragging !== false &&
        (enableColumnDragging ||
            (enableColumnOrdering && columnDef.enableColumnOrdering !== false) ||
            (enableGrouping &&
                columnDef.enableGrouping !== false &&
                !grouping.includes(column.id)));
    const headerPL = react.useMemo(() => {
        let pl = 0;
        if (column.getCanSort())
            pl++;
        if (showColumnActions)
            pl += 1.75;
        if (showDragHandle)
            pl += 1.25;
        return pl;
    }, [showColumnActions, showDragHandle]);
    const draggingBorder = react.useMemo(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id
        ? `1px dashed ${theme.colors.gray[7]} !important`
        : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id
            ? `2px dashed ${getPrimaryColor(theme)} !important`
            : undefined, [draggingColumn, hoveredColumn]);
    const draggingBorders = draggingBorder
        ? {
            borderLeft: draggingBorder,
            borderRight: draggingBorder,
            borderTop: draggingBorder,
        }
        : undefined;
    const handleDragEnter = (_e) => {
        if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === 'drop-zone') {
            setHoveredColumn(null);
        }
        if (enableColumnOrdering && draggingColumn && columnDefType !== 'group') {
            setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
        }
    };
    const headerElement = (columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) instanceof Function
        ? (_a = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
            column,
            header,
            table,
        })
        : (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.Header) !== null && _b !== void 0 ? _b : columnDef.header;
    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: "th", align: columnDefType === 'group' ? 'center' : 'left', colSpan: header.colSpan, onDragEnter: handleDragEnter, ref: (node) => {
            if (node) {
                tableHeadCellRefs.current[column.id] = node;
            }
        } }, tableCellProps, { sx: (theme) => (Object.assign(Object.assign({ flexDirection: layoutMode === 'grid' ? 'column' : undefined, fontWeight: 'bold', overflow: 'visible', padding: density === 'xl' ? '23px' : density === 'md' ? '16px' : '10px', userSelect: enableMultiSort && column.getCanSort() ? 'none' : undefined, verticalAlign: 'top', zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id
                ? 3
                : column.getIsPinned() && columnDefType !== 'group'
                    ? 2
                    : 1, '&:hover .mantine-ActionIcon-root': {
                opacity: 1,
            } }, getCommonCellStyles({
            column,
            header,
            table,
            tableCellProps,
            theme,
        })), draggingBorders)), children: [header.isPlaceholder ? null : (jsxRuntime.jsxs(core.Flex, { className: "mantine-TableHeadCell-Content", sx: {
                    alignItems: 'flex-start',
                    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',
                    justifyContent: columnDefType === 'group' || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'
                        ? 'center'
                        : column.getCanResize()
                            ? 'space-between'
                            : 'flex-start',
                    position: 'relative',
                    width: '100%',
                }, children: [jsxRuntime.jsxs(core.Flex, { className: "mantine-TableHeadCell-Content-Labels", onClick: column.getToggleSortingHandler(), sx: {
                            alignItems: 'center',
                            cursor: column.getCanSort() && columnDefType !== 'group'
                                ? 'pointer'
                                : undefined,
                            flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'right' ? 'row-reverse' : 'row',
                            overflow: columnDefType === 'data' ? 'hidden' : undefined,
                            paddingLeft: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === 'center'
                                ? `${headerPL}rem`
                                : undefined,
                        }, children: [jsxRuntime.jsx(core.Flex, { className: "mantine-TableHeadCell-Content-Wrapper", sx: {
                                    overflow: columnDefType === 'data' ? 'hidden' : undefined,
                                    textOverflow: 'ellipsis',
                                    whiteSpace: ((_d = (_c = columnDef.header) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) < 20 ? 'nowrap' : 'normal',
                                }, title: columnDefType === 'data' ? columnDef.header : undefined, children: headerElement }), column.getCanSort() && (jsxRuntime.jsx(MRT_TableHeadCellSortLabel, { header: header, table: table })), column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterLabel, { header: header, table: table }))] }), columnDefType !== 'group' && (jsxRuntime.jsxs(core.Flex, { className: "mantine-TableHeadCell-Content-Actions", sx: {
                            alignItems: 'center',
                            alignSelf: 'center',
                            whiteSpace: 'nowrap',
                        }, children: [showDragHandle && (jsxRuntime.jsx(MRT_TableHeadCellGrabHandle, { column: column, table: table, tableHeadCellRef: {
                                    current: tableHeadCellRefs.current[column.id],
                                } })), showColumnActions && (jsxRuntime.jsx(MRT_ColumnActionMenu, { header: header, table: table }))] })), column.getCanResize() && (jsxRuntime.jsx(MRT_TableHeadCellResizeHandle, { header: header, table: table }))] })), columnFilterDisplayMode === 'subheader' && column.getCanFilter() && (jsxRuntime.jsx(MRT_TableHeadCellFilterContainer, { header: header, table: table }))] })));
};

const MRT_TableHeadRow = ({ headerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {
    const { getState, options: { enableStickyHeader, layoutMode, mantineTableHeadRowProps }, } = table;
    const { isFullScreen } = getState();
    const tableRowProps = mantineTableHeadRowProps instanceof Function
        ? mantineTableHeadRowProps({ headerGroup, table })
        : mantineTableHeadRowProps;
    const stickyHeader = enableStickyHeader || isFullScreen;
    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: "tr" }, tableRowProps, { sx: (theme) => (Object.assign(Object.assign({ backgroundColor: theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white, boxShadow: `0 4px 8px ${theme.fn.rgba(theme.black, 0.1)}`, display: layoutMode === 'grid' ? 'flex' : 'table-row', top: stickyHeader ? 0 : undefined }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function
            ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme)
            : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx)), { position: stickyHeader ? 'sticky' : undefined })), children: [virtualPaddingLeft ? (jsxRuntime.jsx("th", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader) => {
                const header = virtualColumns
                    ? headerGroup.headers[headerOrVirtualHeader.index]
                    : headerOrVirtualHeader;
                return (jsxRuntime.jsx(MRT_TableHeadCell, { header: header, table: table }, header.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx("th", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));
};

const MRT_TableHead = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {
    const { getHeaderGroups, getSelectedRowModel, getState, options: { enableStickyHeader, layoutMode, mantineTableHeadProps, positionToolbarAlertBanner, }, } = table;
    const { isFullScreen, showAlertBanner } = getState();
    const tableHeadProps = mantineTableHeadProps instanceof Function
        ? mantineTableHeadProps({ table })
        : mantineTableHeadProps;
    const stickyHeader = enableStickyHeader || isFullScreen;
    return (jsxRuntime.jsx(core.Box, Object.assign({ component: "thead" }, tableHeadProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-row-group', position: stickyHeader && layoutMode === 'grid' ? 'sticky' : 'relative', opacity: 0.97, top: stickyHeader ? 0 : undefined, zIndex: stickyHeader ? 2 : undefined }, ((tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx) instanceof Function
            ? tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx(theme)
            : tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx))), children: positionToolbarAlertBanner === 'head-overlay' &&
            (showAlertBanner || getSelectedRowModel().rows.length > 0) ? (jsxRuntime.jsx("tr", { style: { display: layoutMode === 'grid' ? 'grid' : 'table-row' }, children: jsxRuntime.jsx("th", { colSpan: table.getVisibleLeafColumns().length, style: {
                    display: layoutMode === 'grid' ? 'grid' : 'table-cell',
                    padding: 0,
                }, children: jsxRuntime.jsx(MRT_ToolbarAlertBanner, { table: table }) }) })) : (getHeaderGroups().map((headerGroup) => (jsxRuntime.jsx(MRT_TableHeadRow, { headerGroup: headerGroup, table: table, virtualColumns: virtualColumns, virtualPaddingLeft: virtualPaddingLeft, virtualPaddingRight: virtualPaddingRight }, headerGroup.id)))) })));
};

const MRT_TableFooterCell = ({ footer, table, }) => {
    var _a, _b, _c;
    const { options: { layoutMode, mantineTableFooterCellProps }, } = table;
    const { column } = footer;
    const { columnDef } = column;
    const { columnDefType } = columnDef;
    const mTableFooterCellProps = mantineTableFooterCellProps instanceof Function
        ? mantineTableFooterCellProps({ column, table })
        : mantineTableFooterCellProps;
    const mcTableFooterCellProps = columnDef.mantineTableFooterCellProps instanceof Function
        ? columnDef.mantineTableFooterCellProps({ column, table })
        : columnDef.mantineTableFooterCellProps;
    const tableCellProps = Object.assign(Object.assign({}, mTableFooterCellProps), mcTableFooterCellProps);
    return (jsxRuntime.jsx(core.Box, Object.assign({ component: "th", align: columnDefType === 'group' ? 'center' : 'left', colSpan: footer.colSpan }, tableCellProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table-cell', fontWeight: 'bold', justifyContent: columnDefType === 'group' ? 'center' : undefined, padding: '8px', verticalAlign: 'top', zIndex: column.getIsPinned() && columnDefType !== 'group' ? 2 : 1 }, getCommonCellStyles({
            column,
            table,
            theme,
            tableCellProps,
        }))), children: jsxRuntime.jsx(jsxRuntime.Fragment, { children: footer.isPlaceholder
                ? null
                : (_c = (_b = (columnDef.Footer instanceof Function
                    ? (_a = columnDef.Footer) === null || _a === void 0 ? void 0 : _a.call(columnDef, {
                        column,
                        footer,
                        table,
                    })
                    : columnDef.Footer)) !== null && _b !== void 0 ? _b : columnDef.footer) !== null && _c !== void 0 ? _c : null }) })));
};

const MRT_TableFooterRow = ({ footerGroup, table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {
    var _a;
    const { options: { layoutMode, mantineTableFooterRowProps }, } = table;
    // if no content in row, skip row
    if (!((_a = footerGroup.headers) === null || _a === void 0 ? void 0 : _a.some((header) => (typeof header.column.columnDef.footer === 'string' &&
        !!header.column.columnDef.footer) ||
        header.column.columnDef.Footer)))
        return null;
    const tableRowProps = mantineTableFooterRowProps instanceof Function
        ? mantineTableFooterRowProps({ footerGroup, table })
        : mantineTableFooterRowProps;
    return (jsxRuntime.jsxs(core.Box, Object.assign({ component: "tr" }, tableRowProps, { sx: (theme) => (Object.assign({ backgroundColor: theme.fn.lighten(theme.colorScheme === 'dark' ? theme.colors.dark[7] : theme.white, 0.06), display: layoutMode === 'grid' ? 'flex' : 'table-row', width: '100%' }, ((tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx) instanceof Function
            ? tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx(theme)
            : tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx))), children: [virtualPaddingLeft ? (jsxRuntime.jsx("th", { style: { display: 'flex', width: virtualPaddingLeft } })) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter) => {
                const footer = virtualColumns
                    ? footerGroup.headers[footerOrVirtualFooter.index]
                    : footerOrVirtualFooter;
                return (jsxRuntime.jsx(MRT_TableFooterCell, { footer: footer, table: table }, footer.id));
            }), virtualPaddingRight ? (jsxRuntime.jsx("th", { style: { display: 'flex', width: virtualPaddingRight } })) : null] })));
};

const MRT_TableFooter = ({ table, virtualColumns, virtualPaddingLeft, virtualPaddingRight, }) => {
    const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, mantineTableFooterProps }, } = table;
    const { isFullScreen } = getState();
    const tableFooterProps = mantineTableFooterProps instanceof Function
        ? mantineTableFooterProps({ table })
        : mantineTableFooterProps;
    const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
    return (jsxRuntime.jsx(core.Box, Object.assign({ component: "tfoot" }, tableFooterProps, { sx: (theme) => (Object.assign({ bottom: stickFooter ? 0 : undefined, display: layoutMode === 'grid' ? 'grid' : 'table-row-group', opacity: stickFooter ? 0.97 : undefined, outline: stickFooter
                ? theme.colorScheme === 'light'
                    ? `1px solid ${theme.colors.gray[3]}`
                    : `1px solid ${theme.colors.gray[7]}`
                : undefined, position: stickFooter ? 'sticky' : undefined, zIndex: stickFooter ? 1 : undefined }, ((tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx) instanceof Function
            ? tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx(theme)
            : tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx))), children: getFooterGroups().map((footerGroup) => (jsxRuntime.jsx(MRT_TableFooterRow, { footerGroup: footerGroup, table: table, virtualColumns: virtualColumns, virtualPaddingLeft: virtualPaddingLeft, virtualPaddingRight: virtualPaddingRight }, footerGroup.id))) })));
};

const MRT_Table = ({ table, }) => {
    var _a, _b, _c, _d;
    const { getFlatHeaders, getState, options: { columnVirtualizerInstanceRef, columnVirtualizerProps, columns, enableColumnResizing, enableColumnVirtualization, enablePinning, enableTableFooter, enableTableHead, layoutMode, mantineTableProps, memoMode, }, refs: { tableContainerRef }, } = table;
    const { columnPinning, columnSizing, columnSizingInfo, columnVisibility, density, } = getState();
    const tableProps = mantineTableProps instanceof Function
        ? mantineTableProps({ table })
        : mantineTableProps;
    const vProps = columnVirtualizerProps instanceof Function
        ? columnVirtualizerProps({ table })
        : columnVirtualizerProps;
    const columnSizeVars = react.useMemo(() => {
        const headers = getFlatHeaders();
        const colSizes = {};
        for (let i = 0; i < headers.length; i++) {
            const header = headers[i];
            const colSize = header.getSize();
            colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
            colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
        }
        return colSizes;
    }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
    //get first 16 column widths and average them
    const averageColumnWidth = react.useMemo(() => {
        var _a, _b, _c, _d;
        if (!enableColumnVirtualization)
            return 0;
        const columnsWidths = (_d = (_c = (_b = (_a = table
            .getRowModel()
            .rows[0]) === null || _a === void 0 ? void 0 : _a.getCenterVisibleCells()) === null || _b === void 0 ? void 0 : _b.slice(0, 16)) === null || _c === void 0 ? void 0 : _c.map((cell) => cell.column.getSize() * 1.2)) !== null && _d !== void 0 ? _d : [];
        return columnsWidths.reduce((a, b) => a + b, 0) / columnsWidths.length;
    }, [table.getRowModel().rows, columnPinning, columnVisibility]);
    const [leftPinnedIndexes, rightPinnedIndexes] = react.useMemo(() => enableColumnVirtualization && enablePinning
        ? [
            table.getLeftLeafColumns().map((c) => c.getPinnedIndex()),
            table
                .getRightLeafColumns()
                .map((c) => table.getVisibleLeafColumns().length - c.getPinnedIndex() - 1),
        ]
        : [[], []], [columnPinning, enableColumnVirtualization, enablePinning]);
    const columnVirtualizer = enableColumnVirtualization
        ? reactVirtual.useVirtualizer(Object.assign({ count: table.getVisibleLeafColumns().length, estimateSize: () => averageColumnWidth, getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: react.useCallback((range) => [
                ...new Set([
                    ...leftPinnedIndexes,
                    ...reactVirtual.defaultRangeExtractor(range),
                    ...rightPinnedIndexes,
                ]),
            ], [leftPinnedIndexes, rightPinnedIndexes]) }, vProps))
        : undefined;
    if (columnVirtualizerInstanceRef && columnVirtualizer) {
        columnVirtualizerInstanceRef.current = columnVirtualizer;
    }
    const virtualColumns = columnVirtualizer
        ? columnVirtualizer.getVirtualItems()
        : undefined;
    let virtualPaddingLeft;
    let virtualPaddingRight;
    if (columnVirtualizer && (virtualColumns === null || virtualColumns === void 0 ? void 0 : virtualColumns.length)) {
        virtualPaddingLeft = (_b = (_a = virtualColumns[leftPinnedIndexes.length]) === null || _a === void 0 ? void 0 : _a.start) !== null && _b !== void 0 ? _b : 0;
        virtualPaddingRight =
            columnVirtualizer.getTotalSize() -
                ((_d = (_c = virtualColumns[virtualColumns.length - 1 - rightPinnedIndexes.length]) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : 0);
    }
    const props = {
        columnVirtualizer,
        enableHover: tableProps === null || tableProps === void 0 ? void 0 : tableProps.highlightOnHover,
        isStriped: tableProps === null || tableProps === void 0 ? void 0 : tableProps.striped,
        table,
        virtualColumns,
        virtualPaddingLeft,
        virtualPaddingRight,
    };
    return (jsxRuntime.jsxs(core.Table, Object.assign({ highlightOnHover: true, horizontalSpacing: density, verticalSpacing: density }, tableProps, { sx: (theme) => (Object.assign({ display: layoutMode === 'grid' ? 'grid' : 'table', tableLayout: layoutMode !== 'grid' && enableColumnResizing ? 'fixed' : undefined, '& tr:first-of-type td': {
                borderTop: `1px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 8 : 3]}`,
            }, '& tr:last-of-type td': {
                borderBottom: `1px solid ${theme.colors.gray[theme.colorScheme === 'dark' ? 8 : 3]}`,
            } }, ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx) instanceof Function
            ? tableProps.sx(theme)
            : tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx))), style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), children: [enableTableHead && jsxRuntime.jsx(MRT_TableHead, Object.assign({}, props)), memoMode === 'table-body' || columnSizingInfo.isResizingColumn ? (jsxRuntime.jsx(Memo_MRT_TableBody, Object.assign({}, props))) : (jsxRuntime.jsx(MRT_TableBody, Object.assign({}, props))), enableTableFooter && jsxRuntime.jsx(MRT_TableFooter, Object.assign({}, props))] })));
};

const MRT_EditRowModal = ({ open, table, }) => {
    var _a;
    const { getState, options: { onEditingRowCancel, onCreatingRowCancel, renderEditRowModalContent, renderCreateRowModalContent, mantineCreateRowModalProps, mantineEditRowModalProps, }, setEditingRow, setCreatingRow, } = table;
    const { creatingRow, editingRow } = getState();
    const row = (creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow);
    const createModalProps = mantineCreateRowModalProps instanceof Function
        ? mantineCreateRowModalProps({ row, table })
        : mantineCreateRowModalProps;
    const editModalProps = mantineEditRowModalProps instanceof Function
        ? mantineEditRowModalProps({ row, table })
        : mantineEditRowModalProps;
    const modalProps = Object.assign(Object.assign({}, editModalProps), (creatingRow && createModalProps));
    const internalEditComponents = row
        .getAllCells()
        .filter((cell) => cell.column.columnDef.columnDefType === 'data')
        .map((cell) => (jsxRuntime.jsx(MRT_EditCellTextInput, { cell: cell, table: table }, cell.id)));
    const handleCancel = () => {
        var _a;
        if (creatingRow) {
            onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
            setCreatingRow(null);
        }
        else {
            onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
            setEditingRow(null);
        }
        row._valuesCache = {}; //reset values cache
        (_a = modalProps.onClose) === null || _a === void 0 ? void 0 : _a.call(modalProps);
    };
    return (react.createElement(core.Modal, Object.assign({ opened: open, withCloseButton: false }, modalProps, { onClose: handleCancel, key: row.id }), (_a = ((creatingRow &&
        (renderCreateRowModalContent === null || renderCreateRowModalContent === void 0 ? void 0 : renderCreateRowModalContent({
            row,
            table,
            internalEditComponents,
        }))) ||
        (renderEditRowModalContent === null || renderEditRowModalContent === void 0 ? void 0 : renderEditRowModalContent({
            row,
            table,
            internalEditComponents,
        })))) !== null && _a !== void 0 ? _a : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("form", { onSubmit: (e) => e.preventDefault(), children: jsxRuntime.jsx(core.Stack, { sx: {
                        gap: '24px',
                        paddingTop: '16px',
                        width: '100%',
                    }, children: internalEditComponents }) }), jsxRuntime.jsx(core.Flex, { sx: { paddingTop: '24px', justifyContent: 'flex-end' }, children: jsxRuntime.jsx(MRT_EditActionButtons, { row: row, table: table, variant: "text" }) })] }))));
};

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react.useLayoutEffect : react.useEffect;
const MRT_TableContainer = ({ table, }) => {
    const { getState, options: { createDisplayMode, editDisplayMode, enableStickyHeader, mantineLoadingOverlayProps, mantineTableContainerProps, }, refs: { tableContainerRef, bottomToolbarRef, topToolbarRef }, } = table;
    const { isFullScreen, isLoading, showLoadingOverlay, creatingRow, editingRow, } = getState();
    const [totalToolbarHeight, setTotalToolbarHeight] = react.useState(0);
    const tableContainerProps = mantineTableContainerProps instanceof Function
        ? mantineTableContainerProps({ table })
        : mantineTableContainerProps;
    const loadingOverlayProps = mantineLoadingOverlayProps instanceof Function
        ? mantineLoadingOverlayProps({ table })
        : mantineLoadingOverlayProps;
    useIsomorphicLayoutEffect(() => {
        var _a, _b, _c, _d;
        const topToolbarHeight = typeof document !== 'undefined'
            ? (_b = (_a = topToolbarRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) !== null && _b !== void 0 ? _b : 0
            : 0;
        const bottomToolbarHeight = typeof document !== 'undefined'
            ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0
            : 0;
        setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
    });
    const createModalOpen = createDisplayMode === 'modal' && creatingRow;
    const editModalOpen = editDisplayMode === 'modal' && editingRow;
    return (jsxRuntime.jsxs(core.Box, Object.assign({}, tableContainerProps, { ref: (node) => {
            if (node) {
                tableContainerRef.current = node;
                if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
                    //@ts-ignore
                    tableContainerProps.ref.current = node;
                }
            }
        }, sx: (theme) => (Object.assign({ maxWidth: '100%', maxHeight: enableStickyHeader
                ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)`
                : undefined, overflow: 'auto', position: 'relative' }, ((tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx) instanceof Function
            ? tableContainerProps.sx(theme)
            : tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx))), style: Object.assign({ maxHeight: isFullScreen
                ? `calc(100vh - ${totalToolbarHeight}px)`
                : undefined }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), children: [jsxRuntime.jsx(core.LoadingOverlay, Object.assign({ visible: isLoading || showLoadingOverlay }, loadingOverlayProps)), jsxRuntime.jsx(MRT_Table, { table: table }), (createModalOpen || editModalOpen) && (jsxRuntime.jsx(MRT_EditRowModal, { open: true, table: table }))] })));
};

const MRT_TablePaper = ({ table, }) => {
    const { getState, options: { enableBottomToolbar, enableTopToolbar, mantinePaperProps, renderBottomToolbar, renderTopToolbar, }, refs: { tablePaperRef }, } = table;
    const { isFullScreen } = getState();
    const tablePaperProps = mantinePaperProps instanceof Function
        ? mantinePaperProps({ table })
        : mantinePaperProps;
    return (jsxRuntime.jsxs(core.Paper, Object.assign({ shadow: "xs", withBorder: true }, tablePaperProps, { ref: (ref) => {
            tablePaperRef.current = ref;
            if (tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.ref) {
                tablePaperProps.ref.current = ref;
            }
        }, sx: (theme) => (Object.assign({ overflow: 'hidden', transition: 'all 100ms ease-in-out' }, ((tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx) instanceof Function
            ? tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx(theme)
            : tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.sx))), style: Object.assign(Object.assign({}, (isFullScreen
            ? {
                bottom: 0,
                height: '100vh',
                left: 0,
                margin: 0,
                maxHeight: '100vh',
                maxWidth: '100vw',
                padding: 0,
                position: 'fixed',
                right: 0,
                top: 0,
                width: '100vw',
                zIndex: 100,
            }
            : {})), tablePaperProps === null || tablePaperProps === void 0 ? void 0 : tablePaperProps.style), children: [enableTopToolbar &&
                (renderTopToolbar instanceof Function
                    ? renderTopToolbar({ table })
                    : renderTopToolbar !== null && renderTopToolbar !== void 0 ? renderTopToolbar : jsxRuntime.jsx(MRT_TopToolbar, { table: table })), jsxRuntime.jsx(MRT_TableContainer, { table: table }), enableBottomToolbar &&
                (renderBottomToolbar instanceof Function
                    ? renderBottomToolbar({ table })
                    : renderBottomToolbar !== null && renderBottomToolbar !== void 0 ? renderBottomToolbar : jsxRuntime.jsx(MRT_BottomToolbar, { table: table }))] })));
};

const isTableInstanceProp = (props) => props.table !== undefined;
const MantineReactTable = (props) => {
    let table;
    if (isTableInstanceProp(props)) {
        table = props.table;
    }
    else {
        table = useMantineReactTable(props);
    }
    return jsxRuntime.jsx(MRT_TablePaper, { table: table });
};

exports.MRT_AggregationFns = MRT_AggregationFns;
exports.MRT_BottomToolbar = MRT_BottomToolbar;
exports.MRT_ColumnActionMenu = MRT_ColumnActionMenu;
exports.MRT_ColumnPinningButtons = MRT_ColumnPinningButtons;
exports.MRT_CopyButton = MRT_CopyButton;
exports.MRT_DefaultColumn = MRT_DefaultColumn;
exports.MRT_DefaultDisplayColumn = MRT_DefaultDisplayColumn;
exports.MRT_EditActionButtons = MRT_EditActionButtons;
exports.MRT_EditCellTextInput = MRT_EditCellTextInput;
exports.MRT_EditRowModal = MRT_EditRowModal;
exports.MRT_ExpandAllButton = MRT_ExpandAllButton;
exports.MRT_ExpandButton = MRT_ExpandButton;
exports.MRT_FilterCheckbox = MRT_FilterCheckbox;
exports.MRT_FilterFns = MRT_FilterFns;
exports.MRT_FilterOptionMenu = MRT_FilterOptionMenu;
exports.MRT_FilterRangeFields = MRT_FilterRangeFields;
exports.MRT_FilterTextInput = MRT_FilterTextInput;
exports.MRT_GlobalFilterTextInput = MRT_GlobalFilterTextInput;
exports.MRT_GrabHandleButton = MRT_GrabHandleButton;
exports.MRT_ProgressBar = MRT_ProgressBar;
exports.MRT_RowActionMenu = MRT_RowActionMenu;
exports.MRT_SelectCheckbox = MRT_SelectCheckbox;
exports.MRT_ShowHideColumnsButton = MRT_ShowHideColumnsButton;
exports.MRT_ShowHideColumnsMenu = MRT_ShowHideColumnsMenu;
exports.MRT_ShowHideColumnsMenuItems = MRT_ShowHideColumnsMenuItems;
exports.MRT_SortingFns = MRT_SortingFns;
exports.MRT_Table = MRT_Table;
exports.MRT_TableBody = MRT_TableBody;
exports.MRT_TableBodyCell = MRT_TableBodyCell;
exports.MRT_TableBodyCellValue = MRT_TableBodyCellValue;
exports.MRT_TableBodyRow = MRT_TableBodyRow;
exports.MRT_TableBodyRowGrabHandle = MRT_TableBodyRowGrabHandle;
exports.MRT_TableContainer = MRT_TableContainer;
exports.MRT_TableDetailPanel = MRT_TableDetailPanel;
exports.MRT_TableFooter = MRT_TableFooter;
exports.MRT_TableFooterCell = MRT_TableFooterCell;
exports.MRT_TableFooterRow = MRT_TableFooterRow;
exports.MRT_TableHead = MRT_TableHead;
exports.MRT_TableHeadCell = MRT_TableHeadCell;
exports.MRT_TableHeadCellFilterContainer = MRT_TableHeadCellFilterContainer;
exports.MRT_TableHeadCellFilterLabel = MRT_TableHeadCellFilterLabel;
exports.MRT_TableHeadCellGrabHandle = MRT_TableHeadCellGrabHandle;
exports.MRT_TableHeadCellResizeHandle = MRT_TableHeadCellResizeHandle;
exports.MRT_TableHeadCellSortLabel = MRT_TableHeadCellSortLabel;
exports.MRT_TableHeadRow = MRT_TableHeadRow;
exports.MRT_TablePagination = MRT_TablePagination;
exports.MRT_TablePaper = MRT_TablePaper;
exports.MRT_ToggleDensePaddingButton = MRT_ToggleDensePaddingButton;
exports.MRT_ToggleFiltersButton = MRT_ToggleFiltersButton;
exports.MRT_ToggleFullScreenButton = MRT_ToggleFullScreenButton;
exports.MRT_ToggleGlobalFilterButton = MRT_ToggleGlobalFilterButton;
exports.MRT_ToggleRowActionMenuButton = MRT_ToggleRowActionMenuButton;
exports.MRT_ToolbarAlertBanner = MRT_ToolbarAlertBanner;
exports.MRT_ToolbarDropZone = MRT_ToolbarDropZone;
exports.MRT_ToolbarInternalButtons = MRT_ToolbarInternalButtons;
exports.MRT_TopToolbar = MRT_TopToolbar;
exports.MantineReactTable = MantineReactTable;
exports.Memo_MRT_TableBody = Memo_MRT_TableBody;
exports.Memo_MRT_TableBodyCell = Memo_MRT_TableBodyCell;
exports.Memo_MRT_TableBodyRow = Memo_MRT_TableBodyRow;
exports.commonToolbarStyles = commonToolbarStyles;
exports.createRow = createRow;
exports.flexRender = flexRender;
exports.getAllLeafColumnDefs = getAllLeafColumnDefs;
exports.getCanRankRows = getCanRankRows;
exports.getColumnId = getColumnId;
exports.getCommonCellStyles = getCommonCellStyles;
exports.getDefaultColumnFilterFn = getDefaultColumnFilterFn;
exports.getDefaultColumnOrderIds = getDefaultColumnOrderIds;
exports.getIsFirstColumn = getIsFirstColumn;
exports.getIsFirstRightPinnedColumn = getIsFirstRightPinnedColumn;
exports.getIsLastColumn = getIsLastColumn;
exports.getIsLastLeftPinnedColumn = getIsLastLeftPinnedColumn;
exports.getLeadingDisplayColumnIds = getLeadingDisplayColumnIds;
exports.getPrimaryColor = getPrimaryColor;
exports.getPrimaryShade = getPrimaryShade;
exports.getTotalRight = getTotalRight;
exports.getTrailingDisplayColumnIds = getTrailingDisplayColumnIds;
exports.mrtFilterOptions = mrtFilterOptions;
exports.parseCSSVarId = parseCSSVarId;
exports.prepareColumns = prepareColumns;
exports.rankGlobalFuzzy = rankGlobalFuzzy;
exports.reorderColumn = reorderColumn;
exports.showExpandColumn = showExpandColumn;
exports.useMantineReactTable = useMantineReactTable;
//# sourceMappingURL=index.js.map
